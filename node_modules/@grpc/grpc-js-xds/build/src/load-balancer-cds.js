"use strict";
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = exports.CdsLoadBalancer = exports.CdsLoadBalancingConfig = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const xds_client_1 = require("./xds-client");
var UnavailablePicker = grpc_js_1.experimental.UnavailablePicker;
var registerLoadBalancerType = grpc_js_1.experimental.registerLoadBalancerType;
var OutlierDetectionLoadBalancingConfig = grpc_js_1.experimental.OutlierDetectionLoadBalancingConfig;
var QueuePicker = grpc_js_1.experimental.QueuePicker;
const environment_1 = require("./environment");
const load_balancer_xds_cluster_resolver_1 = require("./load-balancer-xds-cluster-resolver");
const cluster_resource_type_1 = require("./xds-resource-type/cluster-resource-type");
const TRACER_NAME = 'cds_balancer';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'cds';
class CdsLoadBalancingConfig {
    constructor(cluster) {
        this.cluster = cluster;
    }
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        return {
            [TYPE_NAME]: {
                cluster: this.cluster
            }
        };
    }
    getCluster() {
        return this.cluster;
    }
    static createFromJson(obj) {
        if ('cluster' in obj) {
            return new CdsLoadBalancingConfig(obj.cluster);
        }
        else {
            throw new Error('Missing "cluster" in cds load balancing config');
        }
    }
}
exports.CdsLoadBalancingConfig = CdsLoadBalancingConfig;
function durationToMs(duration) {
    return (Number(duration.seconds) * 1000 + duration.nanos / 1000000) | 0;
}
function translateOutlierDetectionConfig(outlierDetection) {
    if (!environment_1.EXPERIMENTAL_OUTLIER_DETECTION) {
        return undefined;
    }
    if (!outlierDetection) {
        /* No-op outlier detection config, with all fields unset. */
        return new OutlierDetectionLoadBalancingConfig(null, null, null, null, null, null, []);
    }
    return new OutlierDetectionLoadBalancingConfig(outlierDetection.intervalMs, outlierDetection.baseEjectionTimeMs, outlierDetection.maxEjectionTimeMs, outlierDetection.maxEjectionPercent, outlierDetection.successRateConfig, outlierDetection.failurePercentageConfig, []);
}
function isClusterTreeFullyUpdated(tree, root) {
    const toCheck = [root];
    const visited = new Set();
    while (toCheck.length > 0) {
        const next = toCheck.shift();
        if (visited.has(next)) {
            continue;
        }
        visited.add(next);
        if (!tree[next] || !tree[next].latestUpdate) {
            return false;
        }
        toCheck.push(...tree[next].children);
    }
    return true;
}
function generateDiscoverymechanismForCdsUpdate(config) {
    if (config.type === 'AGGREGATE') {
        throw new Error('Cannot generate DiscoveryMechanism for AGGREGATE cluster');
    }
    return {
        cluster: config.name,
        lrs_load_reporting_server: config.lrsLoadReportingServer,
        max_concurrent_requests: config.maxConcurrentRequests,
        type: config.type,
        eds_service_name: config.edsServiceName,
        dns_hostname: config.dnsHostname,
        outlier_detection: translateOutlierDetectionConfig(config.outlierDetectionUpdate)
    };
}
const RECURSION_DEPTH_LIMIT = 15;
/**
 * Prerequisite: isClusterTreeFullyUpdated(tree, root)
 * @param tree
 * @param root
 */
function getDiscoveryMechanismList(tree, root) {
    const visited = new Set();
    function getDiscoveryMechanismListHelper(node, depth) {
        if (depth > RECURSION_DEPTH_LIMIT) {
            throw new Error('aggregate cluster graph exceeds max depth');
        }
        if (visited.has(node)) {
            return [];
        }
        visited.add(node);
        if (tree[node].children.length > 0) {
            trace('Visit ' + node + ' children: [' + tree[node].children + ']');
            // Aggregate cluster
            const result = [];
            for (const child of tree[node].children) {
                result.push(...getDiscoveryMechanismListHelper(child, depth + 1));
            }
            return result;
        }
        else {
            trace('Visit leaf ' + node);
            // individual cluster
            const config = tree[node].latestUpdate;
            return [generateDiscoverymechanismForCdsUpdate(config)];
        }
    }
    return getDiscoveryMechanismListHelper(root, 0);
}
class CdsLoadBalancer {
    constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.latestCdsUpdate = null;
        this.latestConfig = null;
        this.latestAttributes = {};
        this.xdsClient = null;
        this.clusterTree = {};
        this.updatedChild = false;
        this.childBalancer = new load_balancer_xds_cluster_resolver_1.XdsClusterResolverChildPolicyHandler(channelControlHelper);
    }
    addCluster(cluster) {
        if (cluster in this.clusterTree) {
            return;
        }
        trace('Adding watcher for cluster ' + cluster);
        const watcher = new xds_client_1.Watcher({
            onResourceChanged: (update) => {
                this.clusterTree[cluster].latestUpdate = update;
                if (update.type === 'AGGREGATE') {
                    const children = update.aggregateChildren;
                    trace('Received update for aggregate cluster ' + cluster + ' with children [' + children + ']');
                    this.clusterTree[cluster].children = children;
                    children.forEach(child => this.addCluster(child));
                }
                if (isClusterTreeFullyUpdated(this.clusterTree, this.latestConfig.getCluster())) {
                    let discoveryMechanismList;
                    try {
                        discoveryMechanismList = getDiscoveryMechanismList(this.clusterTree, this.latestConfig.getCluster());
                    }
                    catch (e) {
                        this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({ code: grpc_js_1.status.UNAVAILABLE, details: e.message, metadata: new grpc_js_1.Metadata() }));
                        return;
                    }
                    const clusterResolverConfig = new load_balancer_xds_cluster_resolver_1.XdsClusterResolverLoadBalancingConfig(discoveryMechanismList, [], []);
                    trace('Child update config: ' + JSON.stringify(clusterResolverConfig));
                    this.updatedChild = true;
                    this.childBalancer.updateAddressList([], clusterResolverConfig, this.latestAttributes);
                }
            },
            onResourceDoesNotExist: () => {
                trace('Received onResourceDoesNotExist update for cluster ' + cluster);
                if (cluster in this.clusterTree) {
                    this.clusterTree[cluster].latestUpdate = undefined;
                    this.clusterTree[cluster].children = [];
                }
                this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({ code: grpc_js_1.status.UNAVAILABLE, details: `CDS resource ${cluster} does not exist`, metadata: new grpc_js_1.Metadata() }));
                this.childBalancer.destroy();
            },
            onError: (statusObj) => {
                if (!this.updatedChild) {
                    trace('Transitioning to transient failure due to onError update for cluster' + cluster);
                    this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({
                        code: grpc_js_1.status.UNAVAILABLE,
                        details: `xDS request failed with error ${statusObj.details}`,
                        metadata: new grpc_js_1.Metadata(),
                    }));
                }
            }
        });
        this.clusterTree[cluster] = {
            watcher: watcher,
            children: []
        };
        if (this.xdsClient) {
            cluster_resource_type_1.ClusterResourceType.startWatch(this.xdsClient, cluster, watcher);
        }
    }
    removeCluster(cluster) {
        if (!(cluster in this.clusterTree)) {
            return;
        }
        if (this.xdsClient) {
            cluster_resource_type_1.ClusterResourceType.cancelWatch(this.xdsClient, cluster, this.clusterTree[cluster].watcher);
        }
        delete this.clusterTree[cluster];
    }
    clearClusterTree() {
        for (const cluster of Object.keys(this.clusterTree)) {
            this.removeCluster(cluster);
        }
    }
    updateAddressList(addressList, lbConfig, attributes) {
        if (!(lbConfig instanceof CdsLoadBalancingConfig)) {
            trace('Discarding address list update with unrecognized config ' + JSON.stringify(lbConfig, undefined, 2));
            return;
        }
        trace('Received update with config ' + JSON.stringify(lbConfig, undefined, 2));
        this.latestAttributes = attributes;
        this.xdsClient = attributes.xdsClient;
        /* If the cluster is changing, disable the old watcher before adding the new
         * one */
        if (this.latestConfig && this.latestConfig.getCluster() !== lbConfig.getCluster()) {
            trace('Removing old cluster watchers rooted at ' + this.latestConfig.getCluster());
            this.clearClusterTree();
            this.updatedChild = false;
        }
        if (!this.latestConfig) {
            this.channelControlHelper.updateState(grpc_js_1.connectivityState.CONNECTING, new QueuePicker(this));
        }
        this.latestConfig = lbConfig;
        this.addCluster(lbConfig.getCluster());
    }
    exitIdle() {
        this.childBalancer.exitIdle();
    }
    resetBackoff() {
        this.childBalancer.resetBackoff();
    }
    destroy() {
        var _a;
        trace('Destroying load balancer rooted at cluster named ' + ((_a = this.latestConfig) === null || _a === void 0 ? void 0 : _a.getCluster()));
        this.childBalancer.destroy();
        this.clearClusterTree();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.CdsLoadBalancer = CdsLoadBalancer;
function setup() {
    registerLoadBalancerType(TYPE_NAME, CdsLoadBalancer, CdsLoadBalancingConfig);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-cds.js.map