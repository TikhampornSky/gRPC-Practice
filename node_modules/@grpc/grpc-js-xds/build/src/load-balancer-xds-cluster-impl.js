"use strict";
/*
 * Copyright 2023 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = exports.XdsClusterImplLoadBalancingConfig = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const xds_bootstrap_1 = require("./xds-bootstrap");
var validateLoadBalancingConfig = grpc_js_1.experimental.validateLoadBalancingConfig;
var registerLoadBalancerType = grpc_js_1.experimental.registerLoadBalancerType;
var PickResultType = grpc_js_1.experimental.PickResultType;
var ChildLoadBalancerHandler = grpc_js_1.experimental.ChildLoadBalancerHandler;
var createChildChannelControlHelper = grpc_js_1.experimental.createChildChannelControlHelper;
var getFirstUsableConfig = grpc_js_1.experimental.getFirstUsableConfig;
const TRACER_NAME = 'xds_cluster_impl';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'xds_cluster_impl';
const DEFAULT_MAX_CONCURRENT_REQUESTS = 1024;
function validateDropCategory(obj) {
    if (!('category' in obj && typeof obj.category === 'string')) {
        throw new Error('xds_cluster_impl config drop_categories entry must have a string field category');
    }
    if (!('requests_per_million' in obj && typeof obj.requests_per_million === 'number')) {
        throw new Error('xds_cluster_impl config drop_categories entry must have a number field requests_per_million');
    }
    return obj;
}
class XdsClusterImplLoadBalancingConfig {
    constructor(cluster, dropCategories, childPolicy, edsServiceName, lrsLoadReportingServer, maxConcurrentRequests) {
        this.cluster = cluster;
        this.dropCategories = dropCategories;
        this.childPolicy = childPolicy;
        this.edsServiceName = edsServiceName;
        this.lrsLoadReportingServer = lrsLoadReportingServer;
        this.maxConcurrentRequests = maxConcurrentRequests !== null && maxConcurrentRequests !== void 0 ? maxConcurrentRequests : DEFAULT_MAX_CONCURRENT_REQUESTS;
    }
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        const jsonObj = {
            cluster: this.cluster,
            drop_categories: this.dropCategories,
            child_policy: this.childPolicy.map(policy => policy.toJsonObject()),
            max_concurrent_requests: this.maxConcurrentRequests
        };
        if (this.edsServiceName !== undefined) {
            jsonObj.eds_service_name = this.edsServiceName;
        }
        if (this.lrsLoadReportingServer !== undefined) {
            jsonObj.lrs_load_reporting_server_name = this.lrsLoadReportingServer;
        }
        return {
            [TYPE_NAME]: jsonObj
        };
    }
    getCluster() {
        return this.cluster;
    }
    getEdsServiceName() {
        return this.edsServiceName;
    }
    getLrsLoadReportingServer() {
        return this.lrsLoadReportingServer;
    }
    getMaxConcurrentRequests() {
        return this.maxConcurrentRequests;
    }
    getDropCategories() {
        return this.dropCategories;
    }
    getChildPolicy() {
        return this.childPolicy;
    }
    static createFromJson(obj) {
        if (!('cluster' in obj && typeof obj.cluster === 'string')) {
            throw new Error('xds_cluster_impl config must have a string field cluster');
        }
        if ('eds_service_name' in obj && !(obj.eds_service_name === undefined || typeof obj.eds_service_name === 'string')) {
            throw new Error('xds_cluster_impl config eds_service_name field must be a string if provided');
        }
        if ('max_concurrent_requests' in obj && (!obj.max_concurrent_requests === undefined || typeof obj.max_concurrent_requests === 'number')) {
            throw new Error('xds_cluster_impl config max_concurrent_requests must be a number if provided');
        }
        if (!('drop_categories' in obj && Array.isArray(obj.drop_categories))) {
            throw new Error('xds_cluster_impl config must have an array field drop_categories');
        }
        if (!('child_policy' in obj && Array.isArray(obj.child_policy))) {
            throw new Error('xds_cluster_impl config must have an array field child_policy');
        }
        return new XdsClusterImplLoadBalancingConfig(obj.cluster, obj.drop_categories.map(validateDropCategory), obj.child_policy.map(validateLoadBalancingConfig), obj.eds_service_name, obj.lrs_load_reporting_server ? xds_bootstrap_1.validateXdsServerConfig(obj.lrs_load_reporting_server) : undefined, obj.max_concurrent_requests);
    }
}
exports.XdsClusterImplLoadBalancingConfig = XdsClusterImplLoadBalancingConfig;
class CallCounterMap {
    constructor() {
        this.callCounters = new Map();
    }
    startCall(key) {
        var _a;
        const currentValue = (_a = this.callCounters.get(key)) !== null && _a !== void 0 ? _a : 0;
        this.callCounters.set(key, currentValue + 1);
    }
    endCall(key) {
        var _a;
        const currentValue = (_a = this.callCounters.get(key)) !== null && _a !== void 0 ? _a : 0;
        if (currentValue - 1 <= 0) {
            this.callCounters.delete(key);
        }
        else {
            this.callCounters.set(key, currentValue - 1);
        }
    }
    getConcurrentRequests(key) {
        var _a;
        return (_a = this.callCounters.get(key)) !== null && _a !== void 0 ? _a : 0;
    }
}
const callCounterMap = new CallCounterMap();
class DropPicker {
    constructor(originalPicker, callCounterMapKey, maxConcurrentRequests, dropCategories, clusterDropStats) {
        this.originalPicker = originalPicker;
        this.callCounterMapKey = callCounterMapKey;
        this.maxConcurrentRequests = maxConcurrentRequests;
        this.dropCategories = dropCategories;
        this.clusterDropStats = clusterDropStats;
    }
    checkForMaxConcurrentRequestsDrop() {
        return callCounterMap.getConcurrentRequests(this.callCounterMapKey) >= this.maxConcurrentRequests;
    }
    checkForDrop() {
        for (const dropCategory of this.dropCategories) {
            if (Math.random() * 1000000 < dropCategory.requests_per_million) {
                return dropCategory.category;
            }
        }
        return null;
    }
    pick(pickArgs) {
        var _a, _b;
        let details = null;
        if (this.checkForMaxConcurrentRequestsDrop()) {
            details = 'Call dropped by load balancing policy.';
            (_a = this.clusterDropStats) === null || _a === void 0 ? void 0 : _a.addUncategorizedCallDropped();
        }
        else {
            const category = this.checkForDrop();
            if (category !== null) {
                details = `Call dropped by load balancing policy. Category: ${category}`;
                (_b = this.clusterDropStats) === null || _b === void 0 ? void 0 : _b.addCallDropped(category);
            }
        }
        if (details === null) {
            const originalPick = this.originalPicker.pick(pickArgs);
            return {
                pickResultType: originalPick.pickResultType,
                status: originalPick.status,
                subchannel: originalPick.subchannel,
                onCallStarted: () => {
                    var _a;
                    (_a = originalPick.onCallStarted) === null || _a === void 0 ? void 0 : _a.call(originalPick);
                    callCounterMap.startCall(this.callCounterMapKey);
                },
                onCallEnded: status => {
                    var _a;
                    (_a = originalPick.onCallEnded) === null || _a === void 0 ? void 0 : _a.call(originalPick, status);
                    callCounterMap.endCall(this.callCounterMapKey);
                }
            };
        }
        else {
            return {
                pickResultType: PickResultType.DROP,
                status: {
                    code: grpc_js_1.status.UNAVAILABLE,
                    details: details,
                    metadata: new grpc_js_1.Metadata(),
                },
                subchannel: null,
                onCallEnded: null,
                onCallStarted: null
            };
        }
    }
}
function getCallCounterMapKey(cluster, edsServiceName) {
    return `{${cluster},${edsServiceName !== null && edsServiceName !== void 0 ? edsServiceName : ''}}`;
}
class XdsClusterImplBalancer {
    constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.latestConfig = null;
        this.clusterDropStats = null;
        this.xdsClient = null;
        this.childBalancer = new ChildLoadBalancerHandler(createChildChannelControlHelper(channelControlHelper, {
            updateState: (connectivityState, originalPicker) => {
                if (this.latestConfig === null) {
                    channelControlHelper.updateState(connectivityState, originalPicker);
                }
                else {
                    const picker = new DropPicker(originalPicker, getCallCounterMapKey(this.latestConfig.getCluster(), this.latestConfig.getEdsServiceName()), this.latestConfig.getMaxConcurrentRequests(), this.latestConfig.getDropCategories(), this.clusterDropStats);
                    channelControlHelper.updateState(connectivityState, picker);
                }
            }
        }));
    }
    updateAddressList(addressList, lbConfig, attributes) {
        var _a;
        if (!(lbConfig instanceof XdsClusterImplLoadBalancingConfig)) {
            trace('Discarding address list update with unrecognized config ' + JSON.stringify(lbConfig.toJsonObject(), undefined, 2));
            return;
        }
        trace('Received update with config: ' + JSON.stringify(lbConfig, undefined, 2));
        this.latestConfig = lbConfig;
        this.xdsClient = attributes.xdsClient;
        if (lbConfig.getLrsLoadReportingServer()) {
            this.clusterDropStats = this.xdsClient.addClusterDropStats(lbConfig.getLrsLoadReportingServer(), lbConfig.getCluster(), (_a = lbConfig.getEdsServiceName()) !== null && _a !== void 0 ? _a : '');
        }
        this.childBalancer.updateAddressList(addressList, getFirstUsableConfig(lbConfig.getChildPolicy(), true), attributes);
    }
    exitIdle() {
        this.childBalancer.exitIdle();
    }
    resetBackoff() {
        this.childBalancer.resetBackoff();
    }
    destroy() {
        this.childBalancer.destroy();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
function setup() {
    registerLoadBalancerType(TYPE_NAME, XdsClusterImplBalancer, XdsClusterImplLoadBalancingConfig);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-xds-cluster-impl.js.map