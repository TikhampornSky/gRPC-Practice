"use strict";
/*
 * Copyright 2023 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = exports.XdsClusterResolverChildPolicyHandler = exports.XdsClusterResolver = exports.XdsClusterResolverLoadBalancingConfig = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const load_balancer_1 = require("@grpc/grpc-js/build/src/load-balancer");
const environment_1 = require("./environment");
const load_balancer_lrs_1 = require("./load-balancer-lrs");
const load_balancer_priority_1 = require("./load-balancer-priority");
const load_balancer_weighted_target_1 = require("./load-balancer-weighted-target");
const xds_client_1 = require("./xds-client");
const load_balancer_xds_cluster_impl_1 = require("./load-balancer-xds-cluster-impl");
var validateLoadBalancingConfig = grpc_js_1.experimental.validateLoadBalancingConfig;
var ChildLoadBalancerHandler = grpc_js_1.experimental.ChildLoadBalancerHandler;
var createResolver = grpc_js_1.experimental.createResolver;
var OutlierDetectionLoadBalancingConfig = grpc_js_1.experimental.OutlierDetectionLoadBalancingConfig;
var subchannelAddressToString = grpc_js_1.experimental.subchannelAddressToString;
const xds_bootstrap_1 = require("./xds-bootstrap");
const endpoint_resource_type_1 = require("./xds-resource-type/endpoint-resource-type");
const TRACER_NAME = 'xds_cluster_resolver';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
function validateDiscoveryMechanism(obj) {
    if (!('cluster' in obj && typeof obj.cluster === 'string')) {
        throw new Error('discovery_mechanisms entry must have a string field cluster');
    }
    if (!('type' in obj && (obj.type === 'EDS' || obj.type === 'LOGICAL_DNS'))) {
        throw new Error('discovery_mechanisms entry must have a field "type" with the value "EDS" or "LOGICAL_DNS"');
    }
    if ('max_concurrent_requests' in obj && typeof obj.max_concurrent_requests !== "number") {
        throw new Error('discovery_mechanisms entry max_concurrent_requests field must be a number if provided');
    }
    if ('eds_service_name' in obj && typeof obj.eds_service_name !== 'string') {
        throw new Error('discovery_mechanisms entry eds_service_name field must be a string if provided');
    }
    if ('dns_hostname' in obj && typeof obj.dns_hostname !== 'string') {
        throw new Error('discovery_mechanisms entry dns_hostname field must be a string if provided');
    }
    if (environment_1.EXPERIMENTAL_OUTLIER_DETECTION) {
        const outlierDetectionConfig = validateLoadBalancingConfig(obj.outlier_detection);
        if (!(outlierDetectionConfig instanceof OutlierDetectionLoadBalancingConfig)) {
            throw new Error('eds config outlier_detection must be a valid outlier detection config if provided');
        }
        return Object.assign(Object.assign({}, obj), { lrs_load_reporting_server: xds_bootstrap_1.validateXdsServerConfig(obj.lrs_load_reporting_server), outlier_detection: outlierDetectionConfig });
    }
    return obj;
}
const TYPE_NAME = 'xds_cluster_resolver';
class XdsClusterResolverLoadBalancingConfig {
    constructor(discoveryMechanisms, localityPickingPolicy, endpointPickingPolicy) {
        this.discoveryMechanisms = discoveryMechanisms;
        this.localityPickingPolicy = localityPickingPolicy;
        this.endpointPickingPolicy = endpointPickingPolicy;
    }
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        return {
            [TYPE_NAME]: {
                discovery_mechanisms: this.discoveryMechanisms.map(mechanism => { var _a; return (Object.assign(Object.assign({}, mechanism), { outlier_detection: (_a = mechanism.outlier_detection) === null || _a === void 0 ? void 0 : _a.toJsonObject() })); }),
                locality_picking_policy: this.localityPickingPolicy.map(policy => policy.toJsonObject()),
                endpoint_picking_policy: this.endpointPickingPolicy.map(policy => policy.toJsonObject())
            }
        };
    }
    getDiscoveryMechanisms() {
        return this.discoveryMechanisms;
    }
    getLocalityPickingPolicy() {
        return this.localityPickingPolicy;
    }
    getEndpointPickingPolicy() {
        return this.endpointPickingPolicy;
    }
    static createFromJson(obj) {
        if (!('discovery_mechanisms' in obj && Array.isArray(obj.discovery_mechanisms))) {
            throw new Error('xds_cluster_resolver config must have a discovery_mechanisms array');
        }
        if (!('locality_picking_policy' in obj && Array.isArray(obj.locality_picking_policy))) {
            throw new Error('xds_cluster_resolver config must have a locality_picking_policy array');
        }
        if (!('endpoint_picking_policy' in obj && Array.isArray(obj.endpoint_picking_policy))) {
            throw new Error('xds_cluster_resolver config must have a endpoint_picking_policy array');
        }
        return new XdsClusterResolverLoadBalancingConfig(obj.discovery_mechanisms.map(validateDiscoveryMechanism), obj.locality_picking_policy.map(validateLoadBalancingConfig), obj.endpoint_picking_policy.map(validateLoadBalancingConfig));
    }
}
exports.XdsClusterResolverLoadBalancingConfig = XdsClusterResolverLoadBalancingConfig;
function getEdsPriorities(edsUpdate) {
    const result = [];
    const dropCategories = [];
    if (edsUpdate.policy) {
        for (const dropOverload of edsUpdate.policy.drop_overloads) {
            if (!dropOverload.drop_percentage) {
                continue;
            }
            let requestsPerMillion;
            switch (dropOverload.drop_percentage.denominator) {
                case 'HUNDRED':
                    requestsPerMillion = dropOverload.drop_percentage.numerator * 10000;
                    break;
                case 'TEN_THOUSAND':
                    requestsPerMillion = dropOverload.drop_percentage.numerator * 100;
                    break;
                case 'MILLION':
                    requestsPerMillion = dropOverload.drop_percentage.numerator;
                    break;
            }
            dropCategories.push({
                category: dropOverload.category,
                requests_per_million: requestsPerMillion
            });
        }
    }
    for (const endpoint of edsUpdate.endpoints) {
        if (!endpoint.load_balancing_weight) {
            continue;
        }
        const addresses = endpoint.lb_endpoints.filter(lbEndpoint => lbEndpoint.health_status === 'UNKNOWN' || lbEndpoint.health_status === 'HEALTHY').map((lbEndpoint) => {
            /* The validator in the XdsClient class ensures that each endpoint has
             * a socket_address with an IP address and a port_value. */
            const socketAddress = lbEndpoint.endpoint.address.socket_address;
            return {
                host: socketAddress.address,
                port: socketAddress.port_value,
            };
        });
        if (addresses.length === 0) {
            continue;
        }
        let priorityEntry;
        if (result[endpoint.priority]) {
            priorityEntry = result[endpoint.priority];
        }
        else {
            priorityEntry = {
                localities: [],
                dropCategories: dropCategories
            };
            result[endpoint.priority] = priorityEntry;
        }
        priorityEntry.localities.push({
            locality: endpoint.locality,
            addresses: addresses,
            weight: endpoint.load_balancing_weight.value
        });
    }
    // Collapse spaces in sparse array
    return result.filter(priority => priority);
}
function getDnsPriorities(addresses) {
    return [{
            localities: [{
                    locality: {
                        region: '',
                        zone: '',
                        sub_zone: ''
                    },
                    weight: 1,
                    addresses: addresses
                }],
            dropCategories: []
        }];
}
function localityToName(locality) {
    return `{region=${locality.region},zone=${locality.zone},sub_zone=${locality.sub_zone}}`;
}
function getNextPriorityName(entry) {
    return `cluster=${entry.discoveryMechanism.cluster}, child_number=${entry.nextPriorityChildNumber++}`;
}
class XdsClusterResolver {
    constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.discoveryMechanismList = [];
        this.latestConfig = null;
        this.latestAttributes = {};
        this.xdsClient = null;
        this.childBalancer = new ChildLoadBalancerHandler(grpc_js_1.experimental.createChildChannelControlHelper(channelControlHelper, {
            requestReresolution: () => {
                var _a;
                for (const entry of this.discoveryMechanismList) {
                    (_a = entry.resolver) === null || _a === void 0 ? void 0 : _a.updateResolution();
                }
            }
        }));
    }
    maybeUpdateChild() {
        var _a, _b;
        if (!this.latestConfig) {
            return;
        }
        for (const entry of this.discoveryMechanismList) {
            if (!entry.latestUpdate) {
                return;
            }
        }
        const fullPriorityList = [];
        const priorityChildren = new Map();
        const addressList = [];
        for (const entry of this.discoveryMechanismList) {
            const newPriorityNames = [];
            const newLocalityPriorities = new Map();
            const defaultEndpointPickingPolicy = entry.discoveryMechanism.type === 'EDS' ? validateLoadBalancingConfig({ round_robin: {} }) : validateLoadBalancingConfig({ pick_first: {} });
            const endpointPickingPolicy = [
                ...this.latestConfig.getEndpointPickingPolicy(),
                defaultEndpointPickingPolicy
            ];
            for (const [priority, priorityEntry] of entry.latestUpdate.entries()) {
                /**
                 * Highest (smallest number) priority value that any of the localities in
                 * this locality array had a in the previous mapping.
                 */
                let highestOldPriority = Infinity;
                for (const localityObj of priorityEntry.localities) {
                    const oldPriority = entry.localityPriorities.get(localityToName(localityObj.locality));
                    if (oldPriority !== undefined &&
                        oldPriority >= priority &&
                        oldPriority < highestOldPriority) {
                        highestOldPriority = oldPriority;
                    }
                }
                let newPriorityName;
                if (highestOldPriority === Infinity) {
                    /* No existing priority at or below the same number as the priority we
                     * are looking at had any of the localities in this priority. So, we
                     * use a new name. */
                    newPriorityName = getNextPriorityName(entry);
                }
                else {
                    const newName = entry.priorityNames[highestOldPriority];
                    if (newPriorityNames.indexOf(newName) < 0) {
                        newPriorityName = newName;
                    }
                    else {
                        newPriorityName = getNextPriorityName(entry);
                    }
                }
                newPriorityNames[priority] = newPriorityName;
                const childTargets = new Map();
                for (const localityObj of priorityEntry.localities) {
                    let childPolicy;
                    if (entry.discoveryMechanism.lrs_load_reporting_server !== undefined) {
                        childPolicy = [new load_balancer_lrs_1.LrsLoadBalancingConfig(entry.discoveryMechanism.cluster, (_a = entry.discoveryMechanism.eds_service_name) !== null && _a !== void 0 ? _a : '', entry.discoveryMechanism.lrs_load_reporting_server, localityObj.locality, endpointPickingPolicy)];
                    }
                    else {
                        childPolicy = endpointPickingPolicy;
                    }
                    childTargets.set(localityToName(localityObj.locality), {
                        weight: localityObj.weight,
                        child_policy: childPolicy,
                    });
                    for (const address of localityObj.addresses) {
                        addressList.push(Object.assign({ localityPath: [
                                newPriorityName,
                                localityToName(localityObj.locality),
                            ] }, address));
                    }
                    newLocalityPriorities.set(localityToName(localityObj.locality), priority);
                }
                const weightedTargetConfig = new load_balancer_weighted_target_1.WeightedTargetLoadBalancingConfig(childTargets);
                const xdsClusterImplConfig = new load_balancer_xds_cluster_impl_1.XdsClusterImplLoadBalancingConfig(entry.discoveryMechanism.cluster, priorityEntry.dropCategories, [weightedTargetConfig], entry.discoveryMechanism.eds_service_name, entry.discoveryMechanism.lrs_load_reporting_server, entry.discoveryMechanism.max_concurrent_requests);
                let outlierDetectionConfig;
                if (environment_1.EXPERIMENTAL_OUTLIER_DETECTION) {
                    outlierDetectionConfig = (_b = entry.discoveryMechanism.outlier_detection) === null || _b === void 0 ? void 0 : _b.copyWithChildPolicy([xdsClusterImplConfig]);
                }
                const priorityChildConfig = outlierDetectionConfig !== null && outlierDetectionConfig !== void 0 ? outlierDetectionConfig : xdsClusterImplConfig;
                priorityChildren.set(newPriorityName, {
                    config: [priorityChildConfig],
                    ignore_reresolution_requests: entry.discoveryMechanism.type === 'EDS'
                });
            }
            entry.localityPriorities = newLocalityPriorities;
            entry.priorityNames = newPriorityNames;
            fullPriorityList.push(...newPriorityNames);
        }
        const childConfig = new load_balancer_priority_1.PriorityLoadBalancingConfig(priorityChildren, fullPriorityList);
        trace('Child update addresses: ' + addressList.map(address => '(' + subchannelAddressToString(address) + ' path=' + address.localityPath + ')'));
        trace('Child update priority config: ' + JSON.stringify(childConfig.toJsonObject(), undefined, 2));
        this.childBalancer.updateAddressList(addressList, childConfig, this.latestAttributes);
    }
    updateAddressList(addressList, lbConfig, attributes) {
        var _a;
        if (!(lbConfig instanceof XdsClusterResolverLoadBalancingConfig)) {
            trace('Discarding address list update with unrecognized config ' + JSON.stringify(lbConfig, undefined, 2));
            return;
        }
        trace('Received update with config ' + JSON.stringify(lbConfig, undefined, 2));
        this.latestConfig = lbConfig;
        this.latestAttributes = attributes;
        this.xdsClient = attributes.xdsClient;
        if (this.discoveryMechanismList.length === 0) {
            for (const mechanism of lbConfig.getDiscoveryMechanisms()) {
                const mechanismEntry = {
                    discoveryMechanism: mechanism,
                    localityPriorities: new Map(),
                    priorityNames: [],
                    nextPriorityChildNumber: 0
                };
                if (mechanism.type === 'EDS') {
                    const edsServiceName = (_a = mechanism.eds_service_name) !== null && _a !== void 0 ? _a : mechanism.cluster;
                    const watcher = new xds_client_1.Watcher({
                        onResourceChanged: update => {
                            mechanismEntry.latestUpdate = getEdsPriorities(update);
                            this.maybeUpdateChild();
                        },
                        onResourceDoesNotExist: () => {
                            trace('Resource does not exist: ' + edsServiceName);
                            mechanismEntry.latestUpdate = [{ localities: [], dropCategories: [] }];
                        },
                        onError: error => {
                            if (!mechanismEntry.latestUpdate) {
                                trace('xDS request failed with error ' + error);
                                mechanismEntry.latestUpdate = [{ localities: [], dropCategories: [] }];
                            }
                        }
                    });
                    mechanismEntry.watcher = watcher;
                    if (this.xdsClient) {
                        endpoint_resource_type_1.EndpointResourceType.startWatch(this.xdsClient, edsServiceName, watcher);
                    }
                }
                else {
                    const resolver = createResolver({ scheme: 'dns', path: mechanism.dns_hostname }, {
                        onSuccessfulResolution: addressList => {
                            mechanismEntry.latestUpdate = getDnsPriorities(addressList);
                            this.maybeUpdateChild();
                        },
                        onError: error => {
                            if (!mechanismEntry.latestUpdate) {
                                trace('DNS resolution for ' + mechanism.dns_hostname + ' failed with error ' + error);
                                mechanismEntry.latestUpdate = [{ localities: [], dropCategories: [] }];
                            }
                        }
                    }, { 'grpc.service_config_disable_resolution': 1 });
                    mechanismEntry.resolver = resolver;
                    resolver.updateResolution();
                }
                this.discoveryMechanismList.push(mechanismEntry);
            }
        }
        else {
            /* The ChildLoadBalancerHandler subclass guarantees that each discovery
             * mechanism in the new update corresponds to the same entry in the
             * existing discoveryMechanismList, and that any differences will not
             * result in changes to the watcher/resolver. */
            for (let i = 0; i < this.discoveryMechanismList.length; i++) {
                this.discoveryMechanismList[i].discoveryMechanism = lbConfig.getDiscoveryMechanisms()[i];
            }
            this.maybeUpdateChild();
        }
    }
    exitIdle() {
        this.childBalancer.exitIdle();
    }
    resetBackoff() {
        this.childBalancer.resetBackoff();
    }
    destroy() {
        var _a, _b;
        for (const mechanismEntry of this.discoveryMechanismList) {
            if (mechanismEntry.watcher) {
                const edsServiceName = (_a = mechanismEntry.discoveryMechanism.eds_service_name) !== null && _a !== void 0 ? _a : mechanismEntry.discoveryMechanism.cluster;
                if (this.xdsClient) {
                    endpoint_resource_type_1.EndpointResourceType.cancelWatch(this.xdsClient, edsServiceName, mechanismEntry.watcher);
                }
            }
            (_b = mechanismEntry.resolver) === null || _b === void 0 ? void 0 : _b.destroy();
        }
        this.discoveryMechanismList = [];
        this.childBalancer.destroy();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.XdsClusterResolver = XdsClusterResolver;
function maybeServerConfigEqual(config1, config2) {
    if (config1 !== undefined && config2 !== undefined) {
        return xds_bootstrap_1.serverConfigEqual(config1, config2);
    }
    else {
        return config1 === config2;
    }
}
class XdsClusterResolverChildPolicyHandler extends ChildLoadBalancerHandler {
    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {
        if (!(oldConfig instanceof XdsClusterResolverLoadBalancingConfig && newConfig instanceof XdsClusterResolverLoadBalancingConfig)) {
            return super.configUpdateRequiresNewPolicyInstance(oldConfig, newConfig);
        }
        if (oldConfig.getDiscoveryMechanisms().length !== newConfig.getDiscoveryMechanisms().length) {
            return true;
        }
        for (let i = 0; i < oldConfig.getDiscoveryMechanisms().length; i++) {
            const oldDiscoveryMechanism = oldConfig.getDiscoveryMechanisms()[i];
            const newDiscoveryMechanism = newConfig.getDiscoveryMechanisms()[i];
            if (oldDiscoveryMechanism.type !== newDiscoveryMechanism.type ||
                oldDiscoveryMechanism.cluster !== newDiscoveryMechanism.cluster ||
                oldDiscoveryMechanism.eds_service_name !== newDiscoveryMechanism.eds_service_name ||
                oldDiscoveryMechanism.dns_hostname !== newDiscoveryMechanism.dns_hostname ||
                !maybeServerConfigEqual(oldDiscoveryMechanism.lrs_load_reporting_server, newDiscoveryMechanism.lrs_load_reporting_server)) {
                return true;
            }
        }
        return false;
    }
}
exports.XdsClusterResolverChildPolicyHandler = XdsClusterResolverChildPolicyHandler;
function setup() {
    load_balancer_1.registerLoadBalancerType(TYPE_NAME, XdsClusterResolver, XdsClusterResolverLoadBalancingConfig);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-xds-cluster-resolver.js.map