"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = exports.getListenerResourceName = void 0;
const re2_wasm_1 = require("re2-wasm");
const xds_client_1 = require("./xds-client");
const grpc_js_1 = require("@grpc/grpc-js");
var uriToString = grpc_js_1.experimental.uriToString;
var registerResolver = grpc_js_1.experimental.registerResolver;
const load_balancer_cds_1 = require("./load-balancer-cds");
const load_balancer_xds_cluster_manager_1 = require("./load-balancer-xds-cluster-manager");
const matcher_1 = require("./matcher");
const fraction_1 = require("./fraction");
const route_action_1 = require("./route-action");
const resources_1 = require("./resources");
const http_filter_1 = require("./http-filter");
const environment_1 = require("./environment");
const xds_bootstrap_1 = require("./xds-bootstrap");
const listener_resource_type_1 = require("./xds-resource-type/listener-resource-type");
const route_config_resource_type_1 = require("./xds-resource-type/route-config-resource-type");
const TRACER_NAME = 'xds_resolver';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
// Better match type has smaller value.
var MatchType;
(function (MatchType) {
    MatchType[MatchType["EXACT_MATCH"] = 0] = "EXACT_MATCH";
    MatchType[MatchType["SUFFIX_MATCH"] = 1] = "SUFFIX_MATCH";
    MatchType[MatchType["PREFIX_MATCH"] = 2] = "PREFIX_MATCH";
    MatchType[MatchType["UNIVERSE_MATCH"] = 3] = "UNIVERSE_MATCH";
    MatchType[MatchType["INVALID_MATCH"] = 4] = "INVALID_MATCH";
})(MatchType || (MatchType = {}));
;
function domainPatternMatchType(domainPattern) {
    if (domainPattern.length === 0) {
        return MatchType.INVALID_MATCH;
    }
    if (domainPattern.indexOf('*') < 0) {
        return MatchType.EXACT_MATCH;
    }
    if (domainPattern === '*') {
        return MatchType.UNIVERSE_MATCH;
    }
    if (domainPattern.startsWith('*')) {
        return MatchType.SUFFIX_MATCH;
    }
    if (domainPattern.endsWith('*')) {
        return MatchType.PREFIX_MATCH;
    }
    return MatchType.INVALID_MATCH;
}
function domainMatch(matchType, domainPattern, expectedHostName) {
    switch (matchType) {
        case MatchType.EXACT_MATCH:
            return expectedHostName === domainPattern;
        case MatchType.SUFFIX_MATCH:
            return expectedHostName.endsWith(domainPattern.substring(1));
        case MatchType.PREFIX_MATCH:
            return expectedHostName.startsWith(domainPattern.substring(0, domainPattern.length - 1));
        case MatchType.UNIVERSE_MATCH:
            return true;
        case MatchType.INVALID_MATCH:
            return false;
    }
}
function findVirtualHostForDomain(virutalHostList, domain) {
    let targetVhost = null;
    let bestMatchType = MatchType.INVALID_MATCH;
    let longestMatch = 0;
    for (const virtualHost of virutalHostList) {
        for (const domainPattern of virtualHost.domains) {
            const matchType = domainPatternMatchType(domainPattern);
            // If we already have a match of a better type, skip this one
            if (matchType > bestMatchType) {
                continue;
            }
            // If we already have a longer match of the same type, skip this one
            if (matchType === bestMatchType && domainPattern.length <= longestMatch) {
                continue;
            }
            if (domainMatch(matchType, domainPattern, domain)) {
                targetVhost = virtualHost;
                bestMatchType = matchType;
                longestMatch = domainPattern.length;
            }
            if (bestMatchType === MatchType.EXACT_MATCH) {
                break;
            }
        }
        if (bestMatchType === MatchType.EXACT_MATCH) {
            break;
        }
    }
    return targetVhost;
}
const numberRegex = new re2_wasm_1.RE2(/^-?\d+$/u);
function getPredicateForHeaderMatcher(headerMatch) {
    let valueChecker;
    switch (headerMatch.header_match_specifier) {
        case 'exact_match':
            valueChecker = new matcher_1.ExactValueMatcher(headerMatch.exact_match, false);
            break;
        case 'safe_regex_match':
            valueChecker = new matcher_1.SafeRegexValueMatcher(headerMatch.safe_regex_match.regex);
            break;
        case 'range_match':
            const start = BigInt(headerMatch.range_match.start);
            const end = BigInt(headerMatch.range_match.end);
            valueChecker = new matcher_1.RangeValueMatcher(start, end);
            break;
        case 'present_match':
            valueChecker = new matcher_1.PresentValueMatcher();
            break;
        case 'prefix_match':
            valueChecker = new matcher_1.PrefixValueMatcher(headerMatch.prefix_match, false);
            break;
        case 'suffix_match':
            valueChecker = new matcher_1.SuffixValueMatcher(headerMatch.suffix_match, false);
            break;
        case 'string_match':
            const stringMatch = headerMatch.string_match;
            switch (stringMatch.match_pattern) {
                case 'exact':
                    valueChecker = new matcher_1.ExactValueMatcher(stringMatch.exact, stringMatch.ignore_case);
                    break;
                case 'safe_regex':
                    valueChecker = new matcher_1.SafeRegexValueMatcher(stringMatch.safe_regex.regex);
                    break;
                case 'prefix':
                    valueChecker = new matcher_1.PrefixValueMatcher(stringMatch.prefix, stringMatch.ignore_case);
                    break;
                case 'suffix':
                    valueChecker = new matcher_1.SuffixValueMatcher(stringMatch.suffix, stringMatch.ignore_case);
                    break;
                case 'contains':
                    valueChecker = new matcher_1.ContainsValueMatcher(stringMatch.contains, stringMatch.ignore_case);
                    break;
            }
            break;
        default:
            valueChecker = new matcher_1.RejectValueMatcher();
    }
    return new matcher_1.HeaderMatcher(headerMatch.name, valueChecker, headerMatch.invert_match);
}
function getPredicateForMatcher(routeMatch) {
    var _a, _b;
    let pathMatcher;
    const caseInsensitive = ((_a = routeMatch.case_sensitive) === null || _a === void 0 ? void 0 : _a.value) === false;
    switch (routeMatch.path_specifier) {
        case 'prefix':
            pathMatcher = new matcher_1.PathPrefixValueMatcher(routeMatch.prefix, caseInsensitive);
            break;
        case 'path':
            pathMatcher = new matcher_1.PathExactValueMatcher(routeMatch.path, caseInsensitive);
            break;
        case 'safe_regex':
            pathMatcher = new matcher_1.PathSafeRegexValueMatcher(routeMatch.safe_regex.regex);
            break;
        default:
            pathMatcher = new matcher_1.RejectValueMatcher();
    }
    const headerMatchers = routeMatch.headers.map(getPredicateForHeaderMatcher);
    let runtimeFraction;
    if (!((_b = routeMatch.runtime_fraction) === null || _b === void 0 ? void 0 : _b.default_value)) {
        runtimeFraction = null;
    }
    else {
        runtimeFraction = fraction_1.envoyFractionToFraction(routeMatch.runtime_fraction.default_value);
    }
    return new matcher_1.FullMatcher(pathMatcher, headerMatchers, runtimeFraction);
}
/**
 * Convert a Duration protobuf message object to a Duration object as used in
 * the ServiceConfig definition. The difference is that the protobuf message
 * defines seconds as a long, which is represented as a string in JavaScript,
 * and the one used in the service config defines it as a number.
 * @param duration
 */
function protoDurationToDuration(duration) {
    return {
        seconds: Number.parseInt(duration.seconds),
        nanos: duration.nanos
    };
}
function protoDurationToSecondsString(duration) {
    return `${duration.seconds + duration.nanos / 1000000000}s`;
}
const DEFAULT_RETRY_BASE_INTERVAL = '0.025s';
function getDefaultRetryMaxInterval(baseInterval) {
    return `${Number.parseFloat(baseInterval.substring(0, baseInterval.length - 1)) * 10}s`;
}
/**
 * Encode a text string as a valid path of a URI, as specified in RFC-3986 section 3.3
 * @param uriPath A value representing an unencoded URI path
 * @returns
 */
function encodeURIPath(uriPath) {
    return uriPath.replace(/[^A-Za-z0-9._~!$&^()*+,;=/-]/g, substring => encodeURIComponent(substring));
}
function formatTemplateString(templateString, value) {
    if (templateString.startsWith('xdstp:')) {
        return templateString.replace(/%s/g, encodeURIPath(value));
    }
    else {
        return templateString.replace(/%s/g, value);
    }
}
function getListenerResourceName(bootstrapConfig, target) {
    if (target.authority && target.authority !== '') {
        if (target.authority in bootstrapConfig.authorities) {
            return formatTemplateString(bootstrapConfig.authorities[target.authority].clientListenerResourceNameTemplate, target.path);
        }
        else {
            throw new Error(`Authority ${target.authority} not found in bootstrap file`);
        }
    }
    else {
        return formatTemplateString(bootstrapConfig.clientDefaultListenerResourceNameTemplate, target.path);
    }
}
exports.getListenerResourceName = getListenerResourceName;
const BOOTSTRAP_CONFIG_KEY = 'grpc.TEST_ONLY_DO_NOT_USE_IN_PROD.xds_bootstrap_config';
const RETRY_CODES = {
    'cancelled': grpc_js_1.status.CANCELLED,
    'deadline-exceeded': grpc_js_1.status.DEADLINE_EXCEEDED,
    'internal': grpc_js_1.status.INTERNAL,
    'resource-exhausted': grpc_js_1.status.RESOURCE_EXHAUSTED,
    'unavailable': grpc_js_1.status.UNAVAILABLE
};
class XdsResolver {
    constructor(target, listener, channelOptions) {
        this.target = target;
        this.listener = listener;
        this.channelOptions = channelOptions;
        this.hasReportedSuccess = false;
        this.isLdsWatcherActive = false;
        this.listenerResourceName = null;
        /**
         * The latest route config name from an LDS response. The RDS watcher is
         * actively watching that name if and only if this is not null.
         */
        this.latestRouteConfigName = null;
        this.latestRouteConfig = null;
        this.clusterRefcounts = new Map();
        this.latestDefaultTimeout = undefined;
        this.ldsHttpFilterConfigs = [];
        this.bootstrapInfo = null;
        if (channelOptions[BOOTSTRAP_CONFIG_KEY]) {
            const parsedConfig = JSON.parse(channelOptions[BOOTSTRAP_CONFIG_KEY]);
            this.bootstrapInfo = xds_bootstrap_1.validateBootstrapConfig(parsedConfig);
            this.xdsClient = new xds_client_1.XdsClient(this.bootstrapInfo);
        }
        else {
            this.xdsClient = xds_client_1.getSingletonXdsClient();
        }
        this.ldsWatcher = new xds_client_1.Watcher({
            onResourceChanged: (update) => {
                var _a;
                const httpConnectionManager = resources_1.decodeSingleResource(resources_1.HTTP_CONNECTION_MANGER_TYPE_URL, update.api_listener.api_listener.value);
                const defaultTimeout = (_a = httpConnectionManager.common_http_protocol_options) === null || _a === void 0 ? void 0 : _a.idle_timeout;
                if (defaultTimeout === null || defaultTimeout === undefined) {
                    this.latestDefaultTimeout = undefined;
                }
                else {
                    this.latestDefaultTimeout = protoDurationToDuration(defaultTimeout);
                }
                if (environment_1.EXPERIMENTAL_FAULT_INJECTION) {
                    this.ldsHttpFilterConfigs = [];
                    for (const filter of httpConnectionManager.http_filters) {
                        // typed_config must be set here, or validation would have failed
                        const filterConfig = http_filter_1.parseTopLevelFilterConfig(filter.typed_config);
                        if (filterConfig) {
                            this.ldsHttpFilterConfigs.push({ name: filter.name, config: filterConfig });
                        }
                    }
                }
                switch (httpConnectionManager.route_specifier) {
                    case 'rds': {
                        const routeConfigName = httpConnectionManager.rds.route_config_name;
                        if (this.latestRouteConfigName !== routeConfigName) {
                            if (this.latestRouteConfigName !== null) {
                                route_config_resource_type_1.RouteConfigurationResourceType.cancelWatch(this.xdsClient, this.latestRouteConfigName, this.rdsWatcher);
                            }
                            route_config_resource_type_1.RouteConfigurationResourceType.startWatch(this.xdsClient, routeConfigName, this.rdsWatcher);
                            this.latestRouteConfigName = routeConfigName;
                        }
                        break;
                    }
                    case 'route_config':
                        if (this.latestRouteConfigName) {
                            route_config_resource_type_1.RouteConfigurationResourceType.cancelWatch(this.xdsClient, this.latestRouteConfigName, this.rdsWatcher);
                        }
                        this.handleRouteConfig(httpConnectionManager.route_config);
                        break;
                    default:
                    // This is prevented by the validation rules
                }
            },
            onError: (error) => {
                /* A transient error only needs to bubble up as a failure if we have
                 * not already provided a ServiceConfig for the upper layer to use */
                if (!this.hasReportedSuccess) {
                    trace('Resolution error for target ' + uriToString(this.target) + ' due to xDS client transient error ' + error.details);
                    this.reportResolutionError(error.details);
                }
            },
            onResourceDoesNotExist: () => {
                trace('Resolution error for target ' + uriToString(this.target) + ': LDS resource does not exist');
                this.reportResolutionError(`Listener ${this.target} does not exist`);
            }
        });
        this.rdsWatcher = new xds_client_1.Watcher({
            onResourceChanged: (update) => {
                this.handleRouteConfig(update);
            },
            onError: (error) => {
                /* A transient error only needs to bubble up as a failure if we have
                 * not already provided a ServiceConfig for the upper layer to use */
                if (!this.hasReportedSuccess) {
                    trace('Resolution error for target ' + uriToString(this.target) + ' due to xDS client transient error ' + error.details);
                    this.reportResolutionError(error.details);
                }
            },
            onResourceDoesNotExist: () => {
                trace('Resolution error for target ' + uriToString(this.target) + ' and route config ' + this.latestRouteConfigName + ': RDS resource does not exist');
                this.reportResolutionError(`Route config ${this.latestRouteConfigName} does not exist`);
            }
        });
    }
    refCluster(clusterName) {
        const refCount = this.clusterRefcounts.get(clusterName);
        if (refCount) {
            refCount.refCount += 1;
        }
    }
    unrefCluster(clusterName) {
        const refCount = this.clusterRefcounts.get(clusterName);
        if (refCount) {
            refCount.refCount -= 1;
            if (!refCount.inLastConfig && refCount.refCount === 0) {
                this.clusterRefcounts.delete(clusterName);
                this.handleRouteConfig(this.latestRouteConfig);
            }
        }
    }
    handleRouteConfig(routeConfig) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        this.latestRouteConfig = routeConfig;
        /* Select the virtual host using the default authority override if it
         * exists, and the channel target otherwise. */
        const hostDomain = (_a = this.channelOptions['grpc.default_authority']) !== null && _a !== void 0 ? _a : this.target.path;
        const virtualHost = findVirtualHostForDomain(routeConfig.virtual_hosts, hostDomain);
        if (virtualHost === null) {
            this.reportResolutionError('No matching route found for ' + hostDomain);
            return;
        }
        const virtualHostHttpFilterOverrides = new Map();
        if (environment_1.EXPERIMENTAL_FAULT_INJECTION) {
            for (const [name, filter] of Object.entries((_b = virtualHost.typed_per_filter_config) !== null && _b !== void 0 ? _b : {})) {
                const parsedConfig = http_filter_1.parseOverrideFilterConfig(filter);
                if (parsedConfig) {
                    virtualHostHttpFilterOverrides.set(name, parsedConfig);
                }
            }
        }
        trace('Received virtual host config ' + JSON.stringify(virtualHost, undefined, 2));
        const allConfigClusters = new Set();
        const matchList = [];
        for (const route of virtualHost.routes) {
            let routeAction;
            let timeout;
            /* For field prioritization see
             * https://github.com/grpc/proposal/blob/master/A31-xds-timeout-support-and-config-selector.md#supported-fields
             */
            if ((_d = (_c = route.route) === null || _c === void 0 ? void 0 : _c.max_stream_duration) === null || _d === void 0 ? void 0 : _d.grpc_timeout_header_max) {
                timeout = protoDurationToDuration(route.route.max_stream_duration.grpc_timeout_header_max);
            }
            else if ((_f = (_e = route.route) === null || _e === void 0 ? void 0 : _e.max_stream_duration) === null || _f === void 0 ? void 0 : _f.max_stream_duration) {
                timeout = protoDurationToDuration(route.route.max_stream_duration.max_stream_duration);
            }
            else {
                timeout = this.latestDefaultTimeout;
            }
            // "A value of 0 indicates the application's deadline is used without modification."
            if ((timeout === null || timeout === void 0 ? void 0 : timeout.seconds) === 0 && timeout.nanos === 0) {
                timeout = undefined;
            }
            const routeHttpFilterOverrides = new Map();
            if (environment_1.EXPERIMENTAL_FAULT_INJECTION) {
                for (const [name, filter] of Object.entries((_g = route.typed_per_filter_config) !== null && _g !== void 0 ? _g : {})) {
                    const parsedConfig = http_filter_1.parseOverrideFilterConfig(filter);
                    if (parsedConfig) {
                        routeHttpFilterOverrides.set(name, parsedConfig);
                    }
                }
            }
            let retryPolicy = undefined;
            if (environment_1.EXPERIMENTAL_RETRY) {
                const retryConfig = (_h = route.route.retry_policy) !== null && _h !== void 0 ? _h : virtualHost.retry_policy;
                if (retryConfig) {
                    const retryableStatusCodes = [];
                    for (const code of retryConfig.retry_on.split(',')) {
                        if (RETRY_CODES[code]) {
                            retryableStatusCodes.push(RETRY_CODES[code]);
                        }
                    }
                    if (retryableStatusCodes.length > 0) {
                        const baseInterval = ((_j = retryConfig.retry_back_off) === null || _j === void 0 ? void 0 : _j.base_interval) ?
                            protoDurationToSecondsString(retryConfig.retry_back_off.base_interval) :
                            DEFAULT_RETRY_BASE_INTERVAL;
                        const maxInterval = ((_k = retryConfig.retry_back_off) === null || _k === void 0 ? void 0 : _k.max_interval) ?
                            protoDurationToSecondsString(retryConfig.retry_back_off.max_interval) :
                            getDefaultRetryMaxInterval(baseInterval);
                        retryPolicy = {
                            backoffMultiplier: 2,
                            initialBackoff: baseInterval,
                            maxBackoff: maxInterval,
                            maxAttempts: ((_m = (_l = retryConfig.num_retries) === null || _l === void 0 ? void 0 : _l.value) !== null && _m !== void 0 ? _m : 1) + 1,
                            retryableStatusCodes: retryableStatusCodes
                        };
                    }
                }
            }
            switch (route.route.cluster_specifier) {
                case 'cluster_header':
                    continue;
                case 'cluster': {
                    const cluster = route.route.cluster;
                    allConfigClusters.add(cluster);
                    const extraFilterFactories = [];
                    if (environment_1.EXPERIMENTAL_FAULT_INJECTION) {
                        for (const filterConfig of this.ldsHttpFilterConfigs) {
                            if (routeHttpFilterOverrides.has(filterConfig.name)) {
                                const filter = http_filter_1.createHttpFilter(filterConfig.config, routeHttpFilterOverrides.get(filterConfig.name));
                                if (filter) {
                                    extraFilterFactories.push(filter);
                                }
                            }
                            else if (virtualHostHttpFilterOverrides.has(filterConfig.name)) {
                                const filter = http_filter_1.createHttpFilter(filterConfig.config, virtualHostHttpFilterOverrides.get(filterConfig.name));
                                if (filter) {
                                    extraFilterFactories.push(filter);
                                }
                            }
                            else {
                                const filter = http_filter_1.createHttpFilter(filterConfig.config);
                                if (filter) {
                                    extraFilterFactories.push(filter);
                                }
                            }
                        }
                    }
                    routeAction = new route_action_1.SingleClusterRouteAction(cluster, { name: [], timeout: timeout, retryPolicy: retryPolicy }, extraFilterFactories);
                    break;
                }
                case 'weighted_clusters': {
                    const weightedClusters = [];
                    for (const clusterWeight of route.route.weighted_clusters.clusters) {
                        allConfigClusters.add(clusterWeight.name);
                        const extraFilterFactories = [];
                        const clusterHttpFilterOverrides = new Map();
                        if (environment_1.EXPERIMENTAL_FAULT_INJECTION) {
                            for (const [name, filter] of Object.entries((_o = clusterWeight.typed_per_filter_config) !== null && _o !== void 0 ? _o : {})) {
                                const parsedConfig = http_filter_1.parseOverrideFilterConfig(filter);
                                if (parsedConfig) {
                                    clusterHttpFilterOverrides.set(name, parsedConfig);
                                }
                            }
                            for (const filterConfig of this.ldsHttpFilterConfigs) {
                                if (clusterHttpFilterOverrides.has(filterConfig.name)) {
                                    const filter = http_filter_1.createHttpFilter(filterConfig.config, clusterHttpFilterOverrides.get(filterConfig.name));
                                    if (filter) {
                                        extraFilterFactories.push(filter);
                                    }
                                }
                                else if (routeHttpFilterOverrides.has(filterConfig.name)) {
                                    const filter = http_filter_1.createHttpFilter(filterConfig.config, routeHttpFilterOverrides.get(filterConfig.name));
                                    if (filter) {
                                        extraFilterFactories.push(filter);
                                    }
                                }
                                else if (virtualHostHttpFilterOverrides.has(filterConfig.name)) {
                                    const filter = http_filter_1.createHttpFilter(filterConfig.config, virtualHostHttpFilterOverrides.get(filterConfig.name));
                                    if (filter) {
                                        extraFilterFactories.push(filter);
                                    }
                                }
                                else {
                                    const filter = http_filter_1.createHttpFilter(filterConfig.config);
                                    if (filter) {
                                        extraFilterFactories.push(filter);
                                    }
                                }
                            }
                        }
                        weightedClusters.push({ name: clusterWeight.name, weight: (_q = (_p = clusterWeight.weight) === null || _p === void 0 ? void 0 : _p.value) !== null && _q !== void 0 ? _q : 0, dynamicFilterFactories: extraFilterFactories });
                    }
                    routeAction = new route_action_1.WeightedClusterRouteAction(weightedClusters, (_s = (_r = route.route.weighted_clusters.total_weight) === null || _r === void 0 ? void 0 : _r.value) !== null && _s !== void 0 ? _s : 100, { name: [], timeout: timeout, retryPolicy: retryPolicy });
                    break;
                }
                default:
                    /* The validation logic should prevent us from reaching this point.
                     * This is just for the type checker. */
                    continue;
            }
            const routeMatcher = getPredicateForMatcher(route.match);
            matchList.push({ matcher: routeMatcher, action: routeAction });
        }
        /* Mark clusters that are not in this route config, and remove ones with
          * no references */
        for (const [name, refCount] of Array.from(this.clusterRefcounts.entries())) {
            if (!allConfigClusters.has(name)) {
                refCount.inLastConfig = false;
                if (refCount.refCount === 0) {
                    this.clusterRefcounts.delete(name);
                }
            }
        }
        // Add any new clusters from this route config
        for (const name of allConfigClusters) {
            if (this.clusterRefcounts.has(name)) {
                this.clusterRefcounts.get(name).inLastConfig = true;
            }
            else {
                this.clusterRefcounts.set(name, { inLastConfig: true, refCount: 0 });
            }
        }
        const configSelector = (methodName, metadata) => {
            for (const { matcher, action } of matchList) {
                if (matcher.apply(methodName, metadata)) {
                    const clusterResult = action.getCluster();
                    this.refCluster(clusterResult.name);
                    const onCommitted = () => {
                        this.unrefCluster(clusterResult.name);
                    };
                    return {
                        methodConfig: clusterResult.methodConfig,
                        onCommitted: onCommitted,
                        pickInformation: { cluster: clusterResult.name },
                        status: grpc_js_1.status.OK,
                        dynamicFilterFactories: clusterResult.dynamicFilterFactories
                    };
                }
            }
            return {
                methodConfig: { name: [] },
                // cluster won't be used here, but it's set because of some TypeScript weirdness
                pickInformation: { cluster: '' },
                status: grpc_js_1.status.UNAVAILABLE,
                dynamicFilterFactories: []
            };
        };
        trace('Created ConfigSelector with configuration:');
        for (const { matcher, action } of matchList) {
            trace(matcher.toString());
            trace('=> ' + action.toString());
        }
        const clusterConfigMap = new Map();
        for (const clusterName of this.clusterRefcounts.keys()) {
            clusterConfigMap.set(clusterName, { child_policy: [new load_balancer_cds_1.CdsLoadBalancingConfig(clusterName)] });
        }
        const lbPolicyConfig = new load_balancer_xds_cluster_manager_1.XdsClusterManagerLoadBalancingConfig(clusterConfigMap);
        const serviceConfig = {
            methodConfig: [],
            loadBalancingConfig: [lbPolicyConfig]
        };
        this.listener.onSuccessfulResolution([], serviceConfig, null, configSelector, { xdsClient: this.xdsClient });
    }
    reportResolutionError(reason) {
        this.listener.onError({
            code: grpc_js_1.status.UNAVAILABLE,
            details: `xDS name resolution failed for target ${uriToString(this.target)}: ${reason}`,
            metadata: new grpc_js_1.Metadata(),
        });
    }
    startResolution() {
        if (!this.isLdsWatcherActive) {
            trace('Starting resolution for target ' + uriToString(this.target));
            try {
                this.listenerResourceName = getListenerResourceName(this.bootstrapInfo, this.target);
                trace('Resolving target ' + uriToString(this.target) + ' with Listener resource name ' + this.listenerResourceName);
                listener_resource_type_1.ListenerResourceType.startWatch(this.xdsClient, this.listenerResourceName, this.ldsWatcher);
                this.isLdsWatcherActive = true;
            }
            catch (e) {
                this.reportResolutionError(e.message);
            }
        }
    }
    updateResolution() {
        if (environment_1.EXPERIMENTAL_FEDERATION) {
            if (this.bootstrapInfo) {
                this.startResolution();
            }
            else {
                try {
                    this.bootstrapInfo = xds_bootstrap_1.loadBootstrapInfo();
                }
                catch (e) {
                    this.reportResolutionError(e.message);
                }
                this.startResolution();
            }
        }
        else {
            if (!this.isLdsWatcherActive) {
                trace('Starting resolution for target ' + uriToString(this.target));
                listener_resource_type_1.ListenerResourceType.startWatch(this.xdsClient, this.target.path, this.ldsWatcher);
                this.listenerResourceName = this.target.path;
                this.isLdsWatcherActive = true;
            }
        }
    }
    destroy() {
        if (this.listenerResourceName) {
            listener_resource_type_1.ListenerResourceType.cancelWatch(this.xdsClient, this.listenerResourceName, this.ldsWatcher);
        }
        if (this.latestRouteConfigName) {
            route_config_resource_type_1.RouteConfigurationResourceType.cancelWatch(this.xdsClient, this.latestRouteConfigName, this.rdsWatcher);
        }
    }
    static getDefaultAuthority(target) {
        return target.path;
    }
}
function setup() {
    registerResolver('xds', XdsResolver);
}
exports.setup = setup;
//# sourceMappingURL=resolver-xds.js.map