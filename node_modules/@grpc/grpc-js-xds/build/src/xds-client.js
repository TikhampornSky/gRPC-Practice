"use strict";
/*
 * Copyright 2023 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSingletonXdsClient = exports.XdsClient = exports.Watcher = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const resources_1 = require("./resources");
const xds_bootstrap_1 = require("./xds-bootstrap");
var BackoffTimeout = grpc_js_1.experimental.BackoffTimeout;
const protoLoader = require("@grpc/proto-loader");
const google_default_credentials_1 = require("./google-default-credentials");
const csds_1 = require("./csds");
const TRACER_NAME = 'xds_client';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
let loadedProtos = null;
function loadAdsProtos() {
    if (loadedProtos !== null) {
        return loadedProtos;
    }
    return grpc_js_1.loadPackageDefinition(protoLoader
        .loadSync([
        'envoy/service/discovery/v3/ads.proto',
        'envoy/service/load_stats/v3/lrs.proto',
    ], {
        keepCase: true,
        longs: String,
        enums: String,
        defaults: true,
        oneofs: true,
        json: true,
        includeDirs: [
            // Paths are relative to src/build
            __dirname + '/../../deps/envoy-api/',
            __dirname + '/../../deps/xds/',
            __dirname + '/../../deps/googleapis/',
            __dirname + '/../../deps/protoc-gen-validate/',
        ],
    }));
}
const clientVersion = require('../../package.json').version;
class Watcher {
    constructor(internalWatcher) {
        this.internalWatcher = internalWatcher;
    }
    onGenericResourceChanged(resource) {
        this.internalWatcher.onResourceChanged(resource);
    }
    onError(status) {
        this.internalWatcher.onError(status);
    }
    onResourceDoesNotExist() {
        this.internalWatcher.onResourceDoesNotExist();
    }
}
exports.Watcher = Watcher;
const RESOURCE_TIMEOUT_MS = 15000;
class ResourceTimer {
    constructor(callState, type, name) {
        this.callState = callState;
        this.type = type;
        this.name = name;
        this.timer = null;
        this.resourceSeen = false;
    }
    maybeCancelTimer() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }
    markSeen() {
        this.resourceSeen = true;
        this.maybeCancelTimer();
    }
    markAdsStreamStarted() {
        this.maybeStartTimer();
    }
    maybeStartTimer() {
        var _a;
        if (this.resourceSeen) {
            return;
        }
        if (this.timer) {
            return;
        }
        const authorityState = this.callState.client.xdsClient.authorityStateMap.get(this.name.authority);
        if (!authorityState) {
            return;
        }
        const resourceState = (_a = authorityState.resourceMap.get(this.type)) === null || _a === void 0 ? void 0 : _a.get(this.name.key);
        if (resourceState === null || resourceState === void 0 ? void 0 : resourceState.cachedResource) {
            return;
        }
        this.timer = setTimeout(() => {
            this.onTimer();
        }, RESOURCE_TIMEOUT_MS);
    }
    onTimer() {
        var _a;
        const authorityState = this.callState.client.xdsClient.authorityStateMap.get(this.name.authority);
        const resourceState = (_a = authorityState === null || authorityState === void 0 ? void 0 : authorityState.resourceMap.get(this.type)) === null || _a === void 0 ? void 0 : _a.get(this.name.key);
        if (!resourceState) {
            return;
        }
        resourceState.meta.clientStatus = 'DOES_NOT_EXIST';
        for (const watcher of resourceState.watchers) {
            watcher.onResourceDoesNotExist();
        }
    }
}
/**
 * Responsible for parsing a single ADS response, one resource at a time
 */
class AdsResponseParser {
    constructor(adsCallState) {
        this.adsCallState = adsCallState;
        this.result = {
            errors: [],
            resourcesSeen: new Map(),
            haveValidResources: false
        };
        this.updateTime = new Date();
    }
    processAdsResponseFields(message) {
        const type = this.adsCallState.client.xdsClient.getResourceType(message.type_url);
        if (!type) {
            throw new Error(`Unexpected type URL ${message.type_url}`);
        }
        this.result.type = type;
        this.result.typeUrl = message.type_url;
        this.result.nonce = message.nonce;
        this.result.version = message.version_info;
    }
    parseResource(index, resource) {
        var _a, _b, _c, _d, _e;
        const errorPrefix = `resource index ${index}:`;
        if (resource.type_url !== this.result.typeUrl) {
            this.result.errors.push(`${errorPrefix} incorrect resource type "${resource.type_url}" (should be "${this.result.typeUrl}")`);
            return;
        }
        if (!this.result.type) {
            return;
        }
        const decodeContext = {
            server: this.adsCallState.client.xdsServerConfig
        };
        let decodeResult;
        try {
            decodeResult = this.result.type.decode(decodeContext, resource);
        }
        catch (e) {
            this.result.errors.push(`${errorPrefix} ${e.message}`);
            return;
        }
        let parsedName;
        try {
            parsedName = resources_1.parseXdsResourceName(decodeResult.name, this.result.type.getTypeUrl());
        }
        catch (e) {
            this.result.errors.push(`${errorPrefix} ${e.message}`);
            return;
        }
        (_c = (_b = (_a = this.adsCallState.typeStates.get(this.result.type)) === null || _a === void 0 ? void 0 : _a.subscribedResources.get(parsedName.authority)) === null || _b === void 0 ? void 0 : _b.get(parsedName.key)) === null || _c === void 0 ? void 0 : _c.markSeen();
        if (this.result.type.allResourcesRequiredInSotW()) {
            if (!this.result.resourcesSeen.has(parsedName.authority)) {
                this.result.resourcesSeen.set(parsedName.authority, new Set());
            }
            this.result.resourcesSeen.get(parsedName.authority).add(parsedName.key);
        }
        const resourceState = (_e = (_d = this.adsCallState.client.xdsClient.authorityStateMap.get(parsedName.authority)) === null || _d === void 0 ? void 0 : _d.resourceMap.get(this.result.type)) === null || _e === void 0 ? void 0 : _e.get(parsedName.key);
        if (!resourceState) {
            // No subscription for this resource
            return;
        }
        if (resourceState.deletionIgnored) {
            grpc_js_1.experimental.log(grpc_js_1.logVerbosity.INFO, `Received resource with previously ignored deletion: ${decodeResult.name}`);
            resourceState.deletionIgnored = false;
        }
        if (decodeResult.error) {
            this.result.errors.push(`${errorPrefix} ${decodeResult.error}`);
            process.nextTick(() => {
                for (const watcher of resourceState.watchers) {
                    watcher.onError({ code: grpc_js_1.status.UNAVAILABLE, details: decodeResult.error, metadata: new grpc_js_1.Metadata() });
                }
            });
            resourceState.meta.clientStatus = 'NACKED';
            resourceState.meta.failedVersion = this.result.version;
            resourceState.meta.failedDetails = decodeResult.error;
            resourceState.meta.failedUpdateTime = this.updateTime;
            return;
        }
        if (!decodeResult.value) {
            return;
        }
        this.adsCallState.client.trace('Parsed resource of type ' + this.result.type.getTypeUrl() + ': ' + JSON.stringify(decodeResult.value, undefined, 2));
        this.result.haveValidResources = true;
        if (this.result.type.resourcesEqual(resourceState.cachedResource, decodeResult.value)) {
            return;
        }
        resourceState.cachedResource = decodeResult.value;
        resourceState.meta = {
            clientStatus: 'ACKED',
            rawResource: resource,
            updateTime: this.updateTime,
            version: this.result.version
        };
        process.nextTick(() => {
            for (const watcher of resourceState.watchers) {
                watcher.onGenericResourceChanged(decodeResult.value);
            }
        });
    }
    getResult() {
        return this.result;
    }
}
class AdsCallState {
    constructor(client, call, node) {
        this.client = client;
        this.call = call;
        this.node = node;
        this.typeStates = new Map();
        this.receivedAnyResponse = false;
        this.sentInitialMessage = false;
        // Populate subscription map with existing subscriptions
        for (const [authority, authorityState] of client.xdsClient.authorityStateMap) {
            if (authorityState.client !== client) {
                continue;
            }
            for (const [type, typeMap] of authorityState.resourceMap) {
                for (const key of typeMap.keys()) {
                    this.subscribe(type, { authority, key }, true);
                }
            }
        }
        for (const type of this.typeStates.keys()) {
            this.updateNames(type);
        }
        call.on('data', (message) => {
            this.handleResponseMessage(message);
        });
        call.on('status', (status) => {
            this.handleStreamStatus(status);
        });
        call.on('error', () => { });
    }
    trace(text) {
        this.client.trace(text);
    }
    handleResponseMessage(message) {
        var _a;
        const parser = new AdsResponseParser(this);
        let handledAdsResponseFields;
        try {
            parser.processAdsResponseFields(message);
            handledAdsResponseFields = true;
        }
        catch (e) {
            this.trace('ADS response field parsing failed for type ' + message.type_url);
            handledAdsResponseFields = false;
        }
        if (handledAdsResponseFields) {
            for (const [index, resource] of message.resources.entries()) {
                parser.parseResource(index, resource);
            }
            const result = parser.getResult();
            const typeState = this.typeStates.get(result.type);
            if (!typeState) {
                this.trace('Type state not found for type ' + result.type.getTypeUrl());
                return;
            }
            typeState.nonce = result.nonce;
            if (result.errors.length > 0) {
                typeState.error = `xDS response validation errors: [${result.errors.join('; ')}]`;
            }
            else {
                delete typeState.error;
            }
            // Delete resources not seen in update if needed
            if (result.type.allResourcesRequiredInSotW()) {
                for (const [authority, authorityState] of this.client.xdsClient.authorityStateMap) {
                    if (authorityState.client !== this.client) {
                        continue;
                    }
                    const typeMap = authorityState.resourceMap.get(result.type);
                    if (!typeMap) {
                        continue;
                    }
                    for (const [key, resourceState] of typeMap) {
                        if (!((_a = result.resourcesSeen.get(authority)) === null || _a === void 0 ? void 0 : _a.has(key))) {
                            /* Do nothing for resources that have no cached value. Those are
                             * handled by the resource timer. */
                            if (!resourceState.cachedResource) {
                                continue;
                            }
                            if (this.client.ignoreResourceDeletion) {
                                grpc_js_1.experimental.log(grpc_js_1.logVerbosity.ERROR, 'Ignoring nonexistent resource ' + resources_1.xdsResourceNameToString({ authority, key }, result.type.getTypeUrl()));
                                resourceState.deletionIgnored = true;
                            }
                            else {
                                resourceState.meta.clientStatus = 'DOES_NOT_EXIST';
                                process.nextTick(() => {
                                    for (const watcher of resourceState.watchers) {
                                        watcher.onResourceDoesNotExist();
                                    }
                                });
                            }
                        }
                    }
                }
            }
            if (result.haveValidResources || result.errors.length === 0) {
                this.client.resourceTypeVersionMap.set(result.type, result.version);
            }
            this.updateNames(result.type);
        }
    }
    *allWatchers() {
        var _a, _b, _c, _d;
        for (const [type, typeState] of this.typeStates) {
            for (const [authority, authorityMap] of typeState.subscribedResources) {
                for (const key of authorityMap.keys()) {
                    yield* (_d = (_c = (_b = (_a = this.client.xdsClient.authorityStateMap.get(authority)) === null || _a === void 0 ? void 0 : _a.resourceMap.get(type)) === null || _b === void 0 ? void 0 : _b.get(key)) === null || _c === void 0 ? void 0 : _c.watchers) !== null && _d !== void 0 ? _d : [];
                }
            }
        }
    }
    handleStreamStatus(streamStatus) {
        this.trace('ADS stream ended. code=' + streamStatus.code + ' details= ' + streamStatus.details);
        if (streamStatus.code !== grpc_js_1.status.OK && !this.receivedAnyResponse) {
            for (const watcher of this.allWatchers()) {
                watcher.onError(streamStatus);
            }
        }
        this.client.handleAdsStreamEnd();
    }
    hasSubscribedResources() {
        for (const typeState of this.typeStates.values()) {
            for (const authorityMap of typeState.subscribedResources.values()) {
                if (authorityMap.size > 0) {
                    return true;
                }
            }
        }
        return false;
    }
    subscribe(type, name, delaySend = false) {
        let typeState = this.typeStates.get(type);
        if (!typeState) {
            typeState = {
                nonce: '',
                subscribedResources: new Map()
            };
            this.typeStates.set(type, typeState);
        }
        let authorityMap = typeState.subscribedResources.get(name.authority);
        if (!authorityMap) {
            authorityMap = new Map();
            typeState.subscribedResources.set(name.authority, authorityMap);
        }
        if (!authorityMap.has(name.key)) {
            const timer = new ResourceTimer(this, type, name);
            authorityMap.set(name.key, timer);
            if (!delaySend) {
                this.updateNames(type);
            }
        }
    }
    unsubscribe(type, name) {
        const typeState = this.typeStates.get(type);
        if (!typeState) {
            return;
        }
        const authorityMap = typeState.subscribedResources.get(name.authority);
        if (!authorityMap) {
            return;
        }
        authorityMap.delete(name.key);
        if (authorityMap.size === 0) {
            typeState.subscribedResources.delete(name.authority);
        }
        if (typeState.subscribedResources.size === 0) {
            this.typeStates.delete(type);
        }
        this.updateNames(type);
    }
    resourceNamesForRequest(type) {
        const typeState = this.typeStates.get(type);
        if (!typeState) {
            return [];
        }
        const result = [];
        for (const [authority, authorityMap] of typeState.subscribedResources) {
            for (const [key, timer] of authorityMap) {
                result.push(resources_1.xdsResourceNameToString({ authority, key }, type.getTypeUrl()));
            }
        }
        return result;
    }
    updateNames(type) {
        const typeState = this.typeStates.get(type);
        if (!typeState) {
            return;
        }
        const request = {
            node: this.sentInitialMessage ? null : this.node,
            type_url: type.getFullTypeUrl(),
            response_nonce: typeState.nonce,
            resource_names: this.resourceNamesForRequest(type),
            version_info: this.client.resourceTypeVersionMap.get(type),
            error_detail: typeState.error ? { code: grpc_js_1.status.UNAVAILABLE, message: typeState.error } : null
        };
        this.trace('Sending discovery request: ' + JSON.stringify(request, undefined, 2));
        this.call.write(request);
        this.sentInitialMessage = true;
    }
    end() {
        this.call.end();
    }
    /**
     * Should be called when the channel state is READY after starting the
     * stream.
     */
    markStreamStarted() {
        for (const [type, typeState] of this.typeStates) {
            for (const [authority, authorityMap] of typeState.subscribedResources) {
                for (const resourceTimer of authorityMap.values()) {
                    resourceTimer.markAdsStreamStarted();
                }
            }
        }
    }
}
function localityEqual(loc1, loc2) {
    return (loc1.region === loc2.region &&
        loc1.zone === loc2.zone &&
        loc1.sub_zone === loc2.sub_zone);
}
class ClusterLoadReportMap {
    constructor() {
        this.statsMap = new Set();
    }
    get(clusterName, edsServiceName) {
        for (const statsObj of this.statsMap) {
            if (statsObj.clusterName === clusterName &&
                statsObj.edsServiceName === edsServiceName) {
                return statsObj.stats;
            }
        }
        return undefined;
    }
    /**
     * Get the indicated map entry if it exists, or create a new one if it does
     * not. Increments the refcount of that entry, so a call to this method
     * should correspond to a later call to unref
     * @param clusterName
     * @param edsServiceName
     * @returns
     */
    getOrCreate(clusterName, edsServiceName) {
        for (const statsObj of this.statsMap) {
            if (statsObj.clusterName === clusterName &&
                statsObj.edsServiceName === edsServiceName) {
                statsObj.refCount += 1;
                return statsObj.stats;
            }
        }
        const newStats = {
            callsDropped: new Map(),
            uncategorizedCallsDropped: 0,
            localityStats: new Set(),
            intervalStart: process.hrtime(),
        };
        this.statsMap.add({
            clusterName,
            edsServiceName,
            refCount: 1,
            stats: newStats,
        });
        return newStats;
    }
    *entries() {
        for (const statsEntry of this.statsMap) {
            yield [
                {
                    clusterName: statsEntry.clusterName,
                    edsServiceName: statsEntry.edsServiceName,
                },
                statsEntry.stats,
            ];
        }
    }
    unref(clusterName, edsServiceName) {
        for (const statsObj of this.statsMap) {
            if (statsObj.clusterName === clusterName &&
                statsObj.edsServiceName === edsServiceName) {
                statsObj.refCount -= 1;
                if (statsObj.refCount === 0) {
                    this.statsMap.delete(statsObj);
                }
                return;
            }
        }
    }
    get size() {
        return this.statsMap.size;
    }
}
class LrsCallState {
    constructor(client, call, node) {
        this.client = client;
        this.call = call;
        this.node = node;
        this.statsTimer = null;
        this.sentInitialMessage = false;
        call.on('data', (message) => {
            this.handleResponseMessage(message);
        });
        call.on('status', (status) => {
            this.handleStreamStatus(status);
        });
        call.on('error', () => { });
        this.sendStats();
    }
    handleStreamStatus(status) {
        this.client.trace('LRS stream ended. code=' + status.code + ' details= ' + status.details);
        this.client.handleLrsStreamEnd();
    }
    handleResponseMessage(message) {
        var _a, _b, _c, _d, _e, _f;
        this.client.trace('Received LRS response');
        this.client.onLrsStreamReceivedMessage();
        if (!this.statsTimer ||
            ((_a = message.load_reporting_interval) === null || _a === void 0 ? void 0 : _a.seconds) !== ((_c = (_b = this.client.latestLrsSettings) === null || _b === void 0 ? void 0 : _b.load_reporting_interval) === null || _c === void 0 ? void 0 : _c.seconds) ||
            ((_d = message.load_reporting_interval) === null || _d === void 0 ? void 0 : _d.nanos) !== ((_f = (_e = this.client.latestLrsSettings) === null || _e === void 0 ? void 0 : _e.load_reporting_interval) === null || _f === void 0 ? void 0 : _f.nanos)) {
            /* Only reset the timer if the interval has changed or was not set
             * before. */
            if (this.statsTimer) {
                clearInterval(this.statsTimer);
            }
            /* Convert a google.protobuf.Duration to a number of milliseconds for
             * use with setInterval. */
            const loadReportingIntervalMs = Number.parseInt(message.load_reporting_interval.seconds) * 1000 +
                message.load_reporting_interval.nanos / 1000000;
            this.client.trace('Received LRS response with load reporting interval ' + loadReportingIntervalMs + ' ms');
            this.statsTimer = setInterval(() => {
                this.sendStats();
            }, loadReportingIntervalMs);
        }
        this.client.latestLrsSettings = message;
    }
    sendLrsMessage(clusterStats) {
        const request = {
            node: this.sentInitialMessage ? null : this.node,
            cluster_stats: clusterStats
        };
        this.client.trace('Sending LRS message ' + JSON.stringify(request, undefined, 2));
        this.call.write(request);
        this.sentInitialMessage = true;
    }
    get latestLrsSettings() {
        return this.client.latestLrsSettings;
    }
    sendStats() {
        if (!this.latestLrsSettings) {
            this.sendLrsMessage([]);
            return;
        }
        const clusterStats = [];
        for (const [{ clusterName, edsServiceName }, stats,] of this.client.clusterStatsMap.entries()) {
            if (this.latestLrsSettings.send_all_clusters ||
                this.latestLrsSettings.clusters.indexOf(clusterName) > 0) {
                const upstreamLocalityStats = [];
                for (const localityStats of stats.localityStats) {
                    // Skip localities with 0 requests
                    if (localityStats.callsStarted > 0 ||
                        localityStats.callsSucceeded > 0 ||
                        localityStats.callsFailed > 0) {
                        upstreamLocalityStats.push({
                            locality: localityStats.locality,
                            total_issued_requests: localityStats.callsStarted,
                            total_successful_requests: localityStats.callsSucceeded,
                            total_error_requests: localityStats.callsFailed,
                            total_requests_in_progress: localityStats.callsInProgress,
                        });
                        localityStats.callsStarted = 0;
                        localityStats.callsSucceeded = 0;
                        localityStats.callsFailed = 0;
                    }
                }
                const droppedRequests = [];
                let totalDroppedRequests = 0;
                for (const [category, count] of stats.callsDropped.entries()) {
                    if (count > 0) {
                        droppedRequests.push({
                            category,
                            dropped_count: count,
                        });
                        totalDroppedRequests += count;
                    }
                }
                totalDroppedRequests += stats.uncategorizedCallsDropped;
                // Clear out dropped call stats after sending them
                stats.callsDropped.clear();
                stats.uncategorizedCallsDropped = 0;
                const interval = process.hrtime(stats.intervalStart);
                stats.intervalStart = process.hrtime();
                // Skip clusters with 0 requests
                if (upstreamLocalityStats.length > 0 || totalDroppedRequests > 0) {
                    clusterStats.push({
                        cluster_name: clusterName,
                        cluster_service_name: edsServiceName,
                        dropped_requests: droppedRequests,
                        total_dropped_requests: totalDroppedRequests,
                        upstream_locality_stats: upstreamLocalityStats,
                        load_report_interval: {
                            seconds: interval[0],
                            nanos: interval[1],
                        },
                    });
                }
            }
        }
        this.sendLrsMessage(clusterStats);
    }
}
class XdsSingleServerClient {
    constructor(xdsClient, bootstrapNode, xdsServerConfig) {
        this.xdsClient = xdsClient;
        this.xdsServerConfig = xdsServerConfig;
        this.adsCallState = null;
        this.lrsCallState = null;
        this.clusterStatsMap = new ClusterLoadReportMap();
        this.latestLrsSettings = null;
        /**
         * The number of authorities that are using this client. Streams should only
         * be started if refcount > 0
         */
        this.refcount = 0;
        /**
         * Map of type to latest accepted version string for that type
         */
        this.resourceTypeVersionMap = new Map();
        this.adsBackoff = new BackoffTimeout(() => {
            this.maybeStartAdsStream();
        });
        this.adsBackoff.unref();
        this.lrsBackoff = new BackoffTimeout(() => {
            this.maybeStartLrsStream();
        });
        this.lrsBackoff.unref();
        this.ignoreResourceDeletion = xdsServerConfig.serverFeatures.includes('ignore_resource_deletion');
        const channelArgs = {
            // 5 minutes
            'grpc.keepalive_time_ms': 5 * 60 * 1000
        };
        const credentialsConfigs = xdsServerConfig.channelCreds;
        let channelCreds = null;
        for (const config of credentialsConfigs) {
            if (config.type === 'google_default') {
                channelCreds = google_default_credentials_1.createGoogleDefaultCredentials();
                break;
            }
            else if (config.type === 'insecure') {
                channelCreds = grpc_js_1.ChannelCredentials.createInsecure();
                break;
            }
        }
        const serverUri = this.xdsServerConfig.serverUri;
        this.trace('Starting xDS client connected to server URI ' + this.xdsServerConfig.serverUri);
        /* Bootstrap validation rules guarantee that a matching channel credentials
         * config exists in the list. */
        const channel = new grpc_js_1.Channel(serverUri, channelCreds, channelArgs);
        const protoDefinitions = loadAdsProtos();
        this.adsClient = new protoDefinitions.envoy.service.discovery.v3.AggregatedDiscoveryService(serverUri, channelCreds, { channelOverride: channel });
        channel.watchConnectivityState(channel.getConnectivityState(false), Infinity, () => {
            this.handleAdsConnectivityStateUpdate();
        });
        this.lrsClient = new protoDefinitions.envoy.service.load_stats.v3.LoadReportingService(serverUri, channelCreds, { channelOverride: channel });
    }
    handleAdsConnectivityStateUpdate() {
        var _a;
        const state = this.adsClient.getChannel().getConnectivityState(false);
        if (state === grpc_js_1.connectivityState.READY) {
            (_a = this.adsCallState) === null || _a === void 0 ? void 0 : _a.markStreamStarted();
        }
        if (state === grpc_js_1.connectivityState.TRANSIENT_FAILURE) {
            for (const authorityState of this.xdsClient.authorityStateMap.values()) {
                if (authorityState.client !== this) {
                    continue;
                }
                for (const typeMap of authorityState.resourceMap.values()) {
                    for (const resourceState of typeMap.values()) {
                        for (const watcher of resourceState.watchers) {
                            watcher.onError({
                                code: grpc_js_1.status.UNAVAILABLE,
                                details: 'No connection established to xDS server',
                                metadata: new grpc_js_1.Metadata()
                            });
                        }
                    }
                }
            }
        }
        this.adsClient.getChannel().watchConnectivityState(state, Infinity, () => {
            this.handleAdsConnectivityStateUpdate();
        });
    }
    onAdsStreamReceivedMessage() {
        this.adsBackoff.stop();
        this.adsBackoff.reset();
    }
    handleAdsStreamEnd() {
        this.adsCallState = null;
        /* The backoff timer would start the stream when it finishes. If it is not
         * running, restart the stream immediately. */
        if (!this.adsBackoff.isRunning()) {
            this.maybeStartAdsStream();
        }
    }
    maybeStartAdsStream() {
        if (this.adsCallState || this.refcount < 1) {
            return;
        }
        this.trace('Starting ADS stream');
        const metadata = new grpc_js_1.Metadata({ waitForReady: true });
        const call = this.adsClient.StreamAggregatedResources(metadata);
        this.adsCallState = new AdsCallState(this, call, this.xdsClient.adsNode);
        this.adsBackoff.runOnce();
    }
    onLrsStreamReceivedMessage() {
        this.adsBackoff.stop();
        this.adsBackoff.reset();
    }
    handleLrsStreamEnd() {
        this.lrsCallState = null;
        /* The backoff timer would start the stream when it finishes. If it is not
         * running, restart the stream immediately. */
        if (!this.lrsBackoff.isRunning()) {
            this.maybeStartLrsStream();
        }
    }
    maybeStartLrsStream() {
        if (this.lrsCallState || this.refcount < 1 || this.clusterStatsMap.size < 1) {
            return;
        }
        this.trace('Starting LRS stream');
        const metadata = new grpc_js_1.Metadata({ waitForReady: true });
        const call = this.lrsClient.StreamLoadStats(metadata);
        this.lrsCallState = new LrsCallState(this, call, this.xdsClient.lrsNode);
        this.lrsBackoff.runOnce();
    }
    trace(text) {
        trace(this.xdsServerConfig.serverUri + ' ' + text);
    }
    subscribe(type, name) {
        var _a;
        this.trace('subscribe(type=' + type.getTypeUrl() + ', name=' + resources_1.xdsResourceNameToString(name, type.getTypeUrl()) + ')');
        this.trace(JSON.stringify(name));
        this.maybeStartAdsStream();
        (_a = this.adsCallState) === null || _a === void 0 ? void 0 : _a.subscribe(type, name);
    }
    unsubscribe(type, name) {
        var _a;
        this.trace('unsubscribe(type=' + type.getTypeUrl() + ', name=' + resources_1.xdsResourceNameToString(name, type.getTypeUrl()) + ')');
        (_a = this.adsCallState) === null || _a === void 0 ? void 0 : _a.unsubscribe(type, name);
        if (this.adsCallState && !this.adsCallState.hasSubscribedResources()) {
            this.adsCallState.end();
            this.adsCallState = null;
        }
    }
    ref() {
        this.refcount += 1;
    }
    unref() {
        this.refcount -= 1;
    }
    addClusterDropStats(clusterName, edsServiceName) {
        this.trace('addClusterDropStats(clusterName=' + clusterName + ', edsServiceName=' + edsServiceName + ')');
        const clusterStats = this.clusterStatsMap.getOrCreate(clusterName, edsServiceName);
        this.maybeStartLrsStream();
        return {
            addUncategorizedCallDropped: () => {
                clusterStats.uncategorizedCallsDropped += 1;
            },
            addCallDropped: (category) => {
                var _a;
                const prevCount = (_a = clusterStats.callsDropped.get(category)) !== null && _a !== void 0 ? _a : 0;
                clusterStats.callsDropped.set(category, prevCount + 1);
            },
        };
    }
    removeClusterDropStats(clusterName, edsServiceName) {
        this.trace('removeClusterDropStats(clusterName=' + clusterName + ', edsServiceName=' + edsServiceName + ')');
        this.clusterStatsMap.unref(clusterName, edsServiceName);
    }
    addClusterLocalityStats(clusterName, edsServiceName, locality) {
        this.trace('addClusterLocalityStats(clusterName=' + clusterName + ', edsServiceName=' + edsServiceName + ', locality=' + JSON.stringify(locality) + ')');
        const clusterStats = this.clusterStatsMap.getOrCreate(clusterName, edsServiceName);
        this.maybeStartLrsStream();
        let localityStats = null;
        for (const statsObj of clusterStats.localityStats) {
            if (localityEqual(locality, statsObj.locality)) {
                localityStats = statsObj;
                break;
            }
        }
        if (localityStats === null) {
            localityStats = {
                locality: locality,
                callsInProgress: 0,
                callsStarted: 0,
                callsSucceeded: 0,
                callsFailed: 0,
                refcount: 0,
            };
            clusterStats.localityStats.add(localityStats);
        }
        /* Help the compiler understand that this object is always non-null in the
         * closure */
        const finalLocalityStats = localityStats;
        return {
            addCallStarted: () => {
                finalLocalityStats.callsStarted += 1;
                finalLocalityStats.callsInProgress += 1;
            },
            addCallFinished: (fail) => {
                if (fail) {
                    finalLocalityStats.callsFailed += 1;
                }
                else {
                    finalLocalityStats.callsSucceeded += 1;
                }
                finalLocalityStats.callsInProgress -= 1;
            },
        };
    }
    removeClusterLocalityStats(clusterName, edsServiceName, locality) {
        this.trace('removeClusterLocalityStats(clusterName=' + clusterName + ', edsServiceName=' + edsServiceName + ', locality=' + JSON.stringify(locality) + ')');
        const clusterStats = this.clusterStatsMap.get(clusterName, edsServiceName);
        if (!clusterStats) {
            return;
        }
        for (const statsObj of clusterStats.localityStats) {
            if (localityEqual(locality, statsObj.locality)) {
                statsObj.refcount -= 1;
                if (statsObj.refcount === 0) {
                    clusterStats.localityStats.delete(statsObj);
                }
                break;
            }
        }
        this.clusterStatsMap.unref(clusterName, edsServiceName);
    }
}
const userAgentName = 'gRPC Node Pure JS';
class XdsClient {
    constructor(bootstrapInfoOverride) {
        /**
         * authority -> authority state
         */
        this.authorityStateMap = new Map();
        this.clients = [];
        this.typeRegistry = new Map();
        this.bootstrapInfo = null;
        if (bootstrapInfoOverride) {
            this.bootstrapInfo = bootstrapInfoOverride;
        }
        csds_1.registerXdsClientWithCsds(this);
    }
    getBootstrapInfo() {
        if (!this.bootstrapInfo) {
            this.bootstrapInfo = xds_bootstrap_1.loadBootstrapInfo();
        }
        return this.bootstrapInfo;
    }
    get adsNode() {
        if (!this.bootstrapInfo) {
            return undefined;
        }
        return Object.assign(Object.assign({}, this.bootstrapInfo.node), { user_agent_name: userAgentName, user_agent_version: clientVersion, client_features: ['envoy.lb.does_not_support_overprovisioning'] });
    }
    get lrsNode() {
        if (!this.bootstrapInfo) {
            return undefined;
        }
        return Object.assign(Object.assign({}, this.bootstrapInfo.node), { user_agent_name: userAgentName, user_agent_version: clientVersion, client_features: ['envoy.lrs.supports_send_all_clusters'] });
    }
    getOrCreateClient(authority) {
        var _a, _b;
        const bootstrapInfo = this.getBootstrapInfo();
        let serverConfig;
        if (authority === 'old:') {
            serverConfig = bootstrapInfo.xdsServers[0];
        }
        else {
            if (authority in bootstrapInfo.authorities) {
                serverConfig = (_b = (_a = bootstrapInfo.authorities[authority].xdsServers) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : bootstrapInfo.xdsServers[0];
            }
            else {
                throw new Error(`Authority ${authority} not found in bootstrap authorities list`);
            }
        }
        for (const entry of this.clients) {
            if (xds_bootstrap_1.serverConfigEqual(serverConfig, entry.serverConfig)) {
                return entry.client;
            }
        }
        const client = new XdsSingleServerClient(this, bootstrapInfo.node, serverConfig);
        this.clients.push({ client, serverConfig });
        return client;
    }
    getClient(server) {
        for (const entry of this.clients) {
            if (xds_bootstrap_1.serverConfigEqual(server, entry.serverConfig)) {
                return entry.client;
            }
        }
        return undefined;
    }
    getResourceType(typeUrl) {
        return this.typeRegistry.get(typeUrl);
    }
    watchResource(type, name, watcher) {
        trace('watchResource(type=' + type.getTypeUrl() + ', name=' + name + ')');
        if (this.typeRegistry.has(type.getTypeUrl())) {
            if (this.typeRegistry.get(type.getTypeUrl()) !== type) {
                throw new Error(`Resource type does not match previously used type with the same type URL: ${type.getTypeUrl()}`);
            }
        }
        else {
            this.typeRegistry.set(type.getTypeUrl(), type);
            this.typeRegistry.set(type.getFullTypeUrl(), type);
        }
        const resourceName = resources_1.parseXdsResourceName(name, type.getTypeUrl());
        let authorityState = this.authorityStateMap.get(resourceName.authority);
        if (!authorityState) {
            authorityState = {
                client: this.getOrCreateClient(resourceName.authority),
                resourceMap: new Map()
            };
            authorityState.client.ref();
            this.authorityStateMap.set(resourceName.authority, authorityState);
        }
        let keyMap = authorityState.resourceMap.get(type);
        if (!keyMap) {
            keyMap = new Map();
            authorityState.resourceMap.set(type, keyMap);
        }
        let entry = keyMap.get(resourceName.key);
        let isNewSubscription = false;
        if (!entry) {
            isNewSubscription = true;
            entry = {
                watchers: new Set(),
                cachedResource: null,
                deletionIgnored: false,
                meta: {
                    clientStatus: 'REQUESTED'
                }
            };
            keyMap.set(resourceName.key, entry);
        }
        entry.watchers.add(watcher);
        if (entry.cachedResource) {
            process.nextTick(() => {
                if (entry === null || entry === void 0 ? void 0 : entry.cachedResource) {
                    watcher.onGenericResourceChanged(entry.cachedResource);
                }
            });
        }
        if (isNewSubscription) {
            authorityState.client.subscribe(type, resourceName);
        }
    }
    cancelResourceWatch(type, name, watcher) {
        var _a;
        trace('cancelResourceWatch(type=' + type.getTypeUrl() + ', name=' + name + ')');
        const resourceName = resources_1.parseXdsResourceName(name, type.getTypeUrl());
        const authorityState = this.authorityStateMap.get(resourceName.authority);
        if (!authorityState) {
            return;
        }
        const entry = (_a = authorityState.resourceMap.get(type)) === null || _a === void 0 ? void 0 : _a.get(resourceName.key);
        if (entry) {
            entry.watchers.delete(watcher);
            if (entry.watchers.size === 0) {
                authorityState.resourceMap.get(type).delete(resourceName.key);
                authorityState.client.unsubscribe(type, resourceName);
                if (authorityState.resourceMap.get(type).size === 0) {
                    authorityState.resourceMap.delete(type);
                    if (authorityState.resourceMap.size === 0) {
                        authorityState.client.unref();
                        this.authorityStateMap.delete(resourceName.authority);
                    }
                }
            }
        }
    }
    addClusterDropStats(lrsServer, clusterName, edsServiceName) {
        const client = this.getClient(lrsServer);
        if (!client) {
            return {
                addUncategorizedCallDropped: () => { },
                addCallDropped: (category) => { },
            };
        }
        return client.addClusterDropStats(clusterName, edsServiceName);
    }
    removeClusterDropStats(lrsServer, clusterName, edsServiceName) {
        var _a;
        (_a = this.getClient(lrsServer)) === null || _a === void 0 ? void 0 : _a.removeClusterDropStats(clusterName, edsServiceName);
    }
    addClusterLocalityStats(lrsServer, clusterName, edsServiceName, locality) {
        const client = this.getClient(lrsServer);
        if (!client) {
            return {
                addCallStarted: () => { },
                addCallFinished: (fail) => { },
            };
        }
        return client.addClusterLocalityStats(clusterName, edsServiceName, locality);
    }
    removeClusterLocalityStats(lrsServer, clusterName, edsServiceName, locality) {
        var _a;
        (_a = this.getClient(lrsServer)) === null || _a === void 0 ? void 0 : _a.removeClusterLocalityStats(clusterName, edsServiceName, locality);
    }
}
exports.XdsClient = XdsClient;
let singletonXdsClient = null;
function getSingletonXdsClient() {
    if (singletonXdsClient === null) {
        singletonXdsClient = new XdsClient();
    }
    return singletonXdsClient;
}
exports.getSingletonXdsClient = getSingletonXdsClient;
//# sourceMappingURL=xds-client.js.map