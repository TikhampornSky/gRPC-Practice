"use strict";
/*
 * Copyright 2023 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClusterResourceType = void 0;
const resources_1 = require("../resources");
const xds_resource_type_1 = require("./xds-resource-type");
const environment_1 = require("../environment");
function durationToMs(duration) {
    return (Number(duration.seconds) * 1000 + duration.nanos / 1000000) | 0;
}
function convertOutlierDetectionUpdate(outlierDetection) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (!environment_1.EXPERIMENTAL_OUTLIER_DETECTION) {
        return undefined;
    }
    if (!outlierDetection) {
        /* No-op outlier detection config, with all fields unset. */
        return {
            intervalMs: null,
            baseEjectionTimeMs: null,
            maxEjectionTimeMs: null,
            maxEjectionPercent: null,
            successRateConfig: null,
            failurePercentageConfig: null
        };
    }
    let successRateConfig = null;
    /* Success rate ejection is enabled by default, so we only disable it if
     * enforcing_success_rate is set and it has the value 0 */
    if (!outlierDetection.enforcing_success_rate || outlierDetection.enforcing_success_rate.value > 0) {
        successRateConfig = {
            enforcement_percentage: (_a = outlierDetection.enforcing_success_rate) === null || _a === void 0 ? void 0 : _a.value,
            minimum_hosts: (_b = outlierDetection.success_rate_minimum_hosts) === null || _b === void 0 ? void 0 : _b.value,
            request_volume: (_c = outlierDetection.success_rate_request_volume) === null || _c === void 0 ? void 0 : _c.value,
            stdev_factor: (_d = outlierDetection.success_rate_stdev_factor) === null || _d === void 0 ? void 0 : _d.value
        };
    }
    let failurePercentageConfig = null;
    /* Failure percentage ejection is disabled by default, so we only enable it
     * if enforcing_failure_percentage is set and it has a value greater than 0 */
    if (outlierDetection.enforcing_failure_percentage && outlierDetection.enforcing_failure_percentage.value > 0) {
        failurePercentageConfig = {
            enforcement_percentage: outlierDetection.enforcing_failure_percentage.value,
            minimum_hosts: (_e = outlierDetection.failure_percentage_minimum_hosts) === null || _e === void 0 ? void 0 : _e.value,
            request_volume: (_f = outlierDetection.failure_percentage_request_volume) === null || _f === void 0 ? void 0 : _f.value,
            threshold: (_g = outlierDetection.failure_percentage_threshold) === null || _g === void 0 ? void 0 : _g.value
        };
    }
    return {
        intervalMs: outlierDetection.interval ? durationToMs(outlierDetection.interval) : null,
        baseEjectionTimeMs: outlierDetection.base_ejection_time ? durationToMs(outlierDetection.base_ejection_time) : null,
        maxEjectionTimeMs: outlierDetection.max_ejection_time ? durationToMs(outlierDetection.max_ejection_time) : null,
        maxEjectionPercent: (_j = (_h = outlierDetection.max_ejection_percent) === null || _h === void 0 ? void 0 : _h.value) !== null && _j !== void 0 ? _j : null,
        successRateConfig: successRateConfig,
        failurePercentageConfig: failurePercentageConfig
    };
}
class ClusterResourceType extends xds_resource_type_1.XdsResourceType {
    constructor() {
        super();
    }
    static get() {
        return ClusterResourceType.singleton;
    }
    getTypeUrl() {
        return 'envoy.config.cluster.v3.Cluster';
    }
    validateNonnegativeDuration(duration) {
        if (!duration) {
            return true;
        }
        /* The maximum values here come from the official Protobuf documentation:
         * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Duration
         */
        return Number(duration.seconds) >= 0 &&
            Number(duration.seconds) <= 315576000000 &&
            duration.nanos >= 0 &&
            duration.nanos <= 999999999;
    }
    validatePercentage(percentage) {
        if (!percentage) {
            return true;
        }
        return percentage.value >= 0 && percentage.value <= 100;
    }
    validateResource(context, message) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (message.lb_policy !== 'ROUND_ROBIN') {
            return null;
        }
        if (message.lrs_server) {
            if (!message.lrs_server.self) {
                return null;
            }
        }
        if (environment_1.EXPERIMENTAL_OUTLIER_DETECTION) {
            if (message.outlier_detection) {
                if (!this.validateNonnegativeDuration(message.outlier_detection.interval)) {
                    return null;
                }
                if (!this.validateNonnegativeDuration(message.outlier_detection.base_ejection_time)) {
                    return null;
                }
                if (!this.validateNonnegativeDuration(message.outlier_detection.max_ejection_time)) {
                    return null;
                }
                if (!this.validatePercentage(message.outlier_detection.max_ejection_percent)) {
                    return null;
                }
                if (!this.validatePercentage(message.outlier_detection.enforcing_success_rate)) {
                    return null;
                }
                if (!this.validatePercentage(message.outlier_detection.failure_percentage_threshold)) {
                    return null;
                }
                if (!this.validatePercentage(message.outlier_detection.enforcing_failure_percentage)) {
                    return null;
                }
            }
        }
        if (message.cluster_discovery_type === 'cluster_type') {
            if (!(((_a = message.cluster_type) === null || _a === void 0 ? void 0 : _a.typed_config) && message.cluster_type.typed_config.type_url === resources_1.CLUSTER_CONFIG_TYPE_URL)) {
                return null;
            }
            const clusterConfig = resources_1.decodeSingleResource(resources_1.CLUSTER_CONFIG_TYPE_URL, message.cluster_type.typed_config.value);
            if (clusterConfig.clusters.length === 0) {
                return null;
            }
            return {
                type: 'AGGREGATE',
                name: message.name,
                aggregateChildren: clusterConfig.clusters,
                outlierDetectionUpdate: convertOutlierDetectionUpdate(null)
            };
        }
        else {
            let maxConcurrentRequests = undefined;
            for (const threshold of (_c = (_b = message.circuit_breakers) === null || _b === void 0 ? void 0 : _b.thresholds) !== null && _c !== void 0 ? _c : []) {
                if (threshold.priority === 'DEFAULT') {
                    maxConcurrentRequests = (_d = threshold.max_requests) === null || _d === void 0 ? void 0 : _d.value;
                }
            }
            if (message.type === 'EDS') {
                if (!((_f = (_e = message.eds_cluster_config) === null || _e === void 0 ? void 0 : _e.eds_config) === null || _f === void 0 ? void 0 : _f.ads) && !((_h = (_g = message.eds_cluster_config) === null || _g === void 0 ? void 0 : _g.eds_config) === null || _h === void 0 ? void 0 : _h.self)) {
                    return null;
                }
                if (message.name.startsWith('xdstp:') && message.eds_cluster_config.service_name === '') {
                    return null;
                }
                return {
                    type: 'EDS',
                    name: message.name,
                    aggregateChildren: [],
                    maxConcurrentRequests: maxConcurrentRequests,
                    edsServiceName: message.eds_cluster_config.service_name === '' ? undefined : message.eds_cluster_config.service_name,
                    lrsLoadReportingServer: message.lrs_server ? context.server : undefined,
                    outlierDetectionUpdate: convertOutlierDetectionUpdate(message.outlier_detection)
                };
            }
            else if (message.type === 'LOGICAL_DNS') {
                if (!message.load_assignment) {
                    return null;
                }
                if (message.load_assignment.endpoints.length !== 1) {
                    return null;
                }
                if (message.load_assignment.endpoints[0].lb_endpoints.length !== 1) {
                    return null;
                }
                const socketAddress = (_k = (_j = message.load_assignment.endpoints[0].lb_endpoints[0].endpoint) === null || _j === void 0 ? void 0 : _j.address) === null || _k === void 0 ? void 0 : _k.socket_address;
                if (!socketAddress) {
                    return null;
                }
                if (socketAddress.address === '') {
                    return null;
                }
                if (socketAddress.port_specifier !== 'port_value') {
                    return null;
                }
                return {
                    type: 'LOGICAL_DNS',
                    name: message.name,
                    aggregateChildren: [],
                    maxConcurrentRequests: maxConcurrentRequests,
                    dnsHostname: `${socketAddress.address}:${socketAddress.port_value}`,
                    lrsLoadReportingServer: message.lrs_server ? context.server : undefined,
                    outlierDetectionUpdate: convertOutlierDetectionUpdate(message.outlier_detection)
                };
            }
        }
        return null;
    }
    decode(context, resource) {
        if (resource.type_url !== resources_1.CDS_TYPE_URL) {
            throw new Error(`ADS Error: Invalid resource type ${resource.type_url}, expected ${resources_1.CDS_TYPE_URL}`);
        }
        const message = resources_1.decodeSingleResource(resources_1.CDS_TYPE_URL, resource.value);
        const validatedMessage = this.validateResource(context, message);
        if (validatedMessage) {
            return {
                name: validatedMessage.name,
                value: validatedMessage
            };
        }
        else {
            return {
                name: message.name,
                error: 'Cluster message validation failed'
            };
        }
    }
    allResourcesRequiredInSotW() {
        return true;
    }
    static startWatch(client, name, watcher) {
        client.watchResource(ClusterResourceType.get(), name, watcher);
    }
    static cancelWatch(client, name, watcher) {
        client.cancelResourceWatch(ClusterResourceType.get(), name, watcher);
    }
}
exports.ClusterResourceType = ClusterResourceType;
ClusterResourceType.singleton = new ClusterResourceType();
//# sourceMappingURL=cluster-resource-type.js.map