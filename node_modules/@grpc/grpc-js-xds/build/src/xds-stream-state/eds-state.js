"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdsState = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const net_1 = require("net");
const xds_stream_state_1 = require("./xds-stream-state");
const TRACER_NAME = 'xds_client';
const UINT32_MAX = 0xFFFFFFFF;
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
function localitiesEqual(a, b) {
    return a.region === b.region && a.sub_zone === b.sub_zone && a.zone === b.zone;
}
function addressesEqual(a, b) {
    return a.address === b.address && a.port_value === b.port_value;
}
class EdsState extends xds_stream_state_1.BaseXdsStreamState {
    getResourceName(resource) {
        return resource.cluster_name;
    }
    getProtocolName() {
        return 'EDS';
    }
    isStateOfTheWorld() {
        return false;
    }
    /**
     * Validate the ClusterLoadAssignment object by these rules:
     * https://github.com/grpc/proposal/blob/master/A27-xds-global-load-balancing.md#clusterloadassignment-proto
     * @param message
     */
    validateResponse(message) {
        var _a, _b, _c, _d, _e;
        const seenLocalities = [];
        const seenAddresses = [];
        const priorityTotalWeights = new Map();
        for (const endpoint of message.endpoints) {
            if (!endpoint.locality) {
                trace('EDS validation: endpoint locality unset');
                return false;
            }
            for (const { locality, priority } of seenLocalities) {
                if (localitiesEqual(endpoint.locality, locality) && endpoint.priority === priority) {
                    trace('EDS validation: endpoint locality duplicated: ' + JSON.stringify(locality) + ', priority=' + priority);
                    return false;
                }
            }
            seenLocalities.push({ locality: endpoint.locality, priority: endpoint.priority });
            for (const lb of endpoint.lb_endpoints) {
                const socketAddress = (_b = (_a = lb.endpoint) === null || _a === void 0 ? void 0 : _a.address) === null || _b === void 0 ? void 0 : _b.socket_address;
                if (!socketAddress) {
                    trace('EDS validation: endpoint socket_address not set');
                    return false;
                }
                if (socketAddress.port_specifier !== 'port_value') {
                    trace('EDS validation: socket_address.port_specifier !== "port_value"');
                    return false;
                }
                if (!(net_1.isIPv4(socketAddress.address) || net_1.isIPv6(socketAddress.address))) {
                    trace('EDS validation: address not a valid IPv4 or IPv6 address: ' + socketAddress.address);
                    return false;
                }
                for (const address of seenAddresses) {
                    if (addressesEqual(socketAddress, address)) {
                        trace('EDS validation: duplicate address seen: ' + address);
                        return false;
                    }
                }
                seenAddresses.push(socketAddress);
            }
            priorityTotalWeights.set(endpoint.priority, ((_c = priorityTotalWeights.get(endpoint.priority)) !== null && _c !== void 0 ? _c : 0) + ((_e = (_d = endpoint.load_balancing_weight) === null || _d === void 0 ? void 0 : _d.value) !== null && _e !== void 0 ? _e : 0));
        }
        for (const totalWeight of priorityTotalWeights.values()) {
            if (totalWeight > UINT32_MAX) {
                trace('EDS validation: total weight > UINT32_MAX');
                return false;
            }
        }
        for (const priority of priorityTotalWeights.keys()) {
            if (priority > 0 && !priorityTotalWeights.has(priority - 1)) {
                trace('EDS validation: priorities not contiguous');
                return false;
            }
        }
        return true;
    }
}
exports.EdsState = EdsState;
//# sourceMappingURL=eds-state.js.map