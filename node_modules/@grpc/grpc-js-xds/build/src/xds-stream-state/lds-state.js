"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LdsState = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const xds_stream_state_1 = require("./xds-stream-state");
const resources_1 = require("../resources");
const http_filter_1 = require("../http-filter");
const environment_1 = require("../environment");
const TRACER_NAME = 'xds_client';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const ROUTER_FILTER_URL = 'type.googleapis.com/envoy.extensions.filters.http.router.v3.Router';
class LdsState extends xds_stream_state_1.BaseXdsStreamState {
    constructor(rdsState, updateResourceNames) {
        super(updateResourceNames);
        this.rdsState = rdsState;
    }
    getResourceName(resource) {
        return resource.name;
    }
    getProtocolName() {
        return 'LDS';
    }
    isStateOfTheWorld() {
        return true;
    }
    validateResponse(message) {
        var _a, _b, _c;
        if (!(((_a = message.api_listener) === null || _a === void 0 ? void 0 : _a.api_listener) &&
            message.api_listener.api_listener.type_url === resources_1.HTTP_CONNECTION_MANGER_TYPE_URL)) {
            return false;
        }
        const httpConnectionManager = resources_1.decodeSingleResource(resources_1.HTTP_CONNECTION_MANGER_TYPE_URL, message.api_listener.api_listener.value);
        if (environment_1.EXPERIMENTAL_FAULT_INJECTION) {
            const filterNames = new Set();
            for (const [index, httpFilter] of httpConnectionManager.http_filters.entries()) {
                if (filterNames.has(httpFilter.name)) {
                    trace('LDS response validation failed: duplicate HTTP filter name ' + httpFilter.name);
                    return false;
                }
                filterNames.add(httpFilter.name);
                if (!http_filter_1.validateTopLevelFilter(httpFilter)) {
                    trace('LDS response validation failed: ' + httpFilter.name + ' filter validation failed');
                    return false;
                }
                /* Validate that the last filter, and only the last filter, is the
                 * router filter. */
                const filterUrl = http_filter_1.getTopLevelFilterUrl(httpFilter.typed_config);
                if (index < httpConnectionManager.http_filters.length - 1) {
                    if (filterUrl === ROUTER_FILTER_URL) {
                        trace('LDS response validation failed: router filter is before end of list');
                        return false;
                    }
                }
                else {
                    if (filterUrl !== ROUTER_FILTER_URL) {
                        trace('LDS response validation failed: final filter is ' + filterUrl);
                        return false;
                    }
                }
            }
        }
        switch (httpConnectionManager.route_specifier) {
            case 'rds':
                return !!((_c = (_b = httpConnectionManager.rds) === null || _b === void 0 ? void 0 : _b.config_source) === null || _c === void 0 ? void 0 : _c.ads);
            case 'route_config':
                return this.rdsState.validateResponse(httpConnectionManager.route_config);
        }
        return false;
    }
}
exports.LdsState = LdsState;
//# sourceMappingURL=lds-state.js.map