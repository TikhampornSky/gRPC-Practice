"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseXdsStreamState = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const TRACER_NAME = 'xds_client';
const RESOURCE_TIMEOUT_MS = 15000;
class BaseXdsStreamState {
    constructor(updateResourceNames) {
        this.updateResourceNames = updateResourceNames;
        this.versionInfo = '';
        this.nonce = '';
        this.subscriptions = new Map();
        this.isAdsStreamRunning = false;
        this.ignoreResourceDeletion = false;
    }
    trace(text) {
        grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, this.getProtocolName() + ' | ' + text);
    }
    startResourceTimer(subscriptionEntry) {
        clearTimeout(subscriptionEntry.resourceTimer);
        subscriptionEntry.resourceTimer = setTimeout(() => {
            for (const watcher of subscriptionEntry.watchers) {
                watcher.onResourceDoesNotExist();
            }
        }, RESOURCE_TIMEOUT_MS);
    }
    addWatcher(name, watcher) {
        this.trace('Adding watcher for name ' + name);
        let subscriptionEntry = this.subscriptions.get(name);
        let addedName = false;
        if (subscriptionEntry === undefined) {
            addedName = true;
            subscriptionEntry = {
                watchers: [],
                cachedResponse: null,
                resourceTimer: setTimeout(() => { }, 0),
                deletionIgnored: false
            };
            if (this.isAdsStreamRunning) {
                this.startResourceTimer(subscriptionEntry);
            }
            this.subscriptions.set(name, subscriptionEntry);
        }
        subscriptionEntry.watchers.push(watcher);
        if (subscriptionEntry.cachedResponse !== null) {
            const cachedResponse = subscriptionEntry.cachedResponse;
            /* These updates normally occur asynchronously, so we ensure that
             * the same happens here */
            process.nextTick(() => {
                this.trace('Reporting existing update for new watcher for name ' + name);
                watcher.onValidUpdate(cachedResponse);
            });
        }
        if (addedName) {
            this.updateResourceNames();
        }
    }
    removeWatcher(resourceName, watcher) {
        this.trace('Removing watcher for name ' + resourceName);
        const subscriptionEntry = this.subscriptions.get(resourceName);
        if (subscriptionEntry !== undefined) {
            const entryIndex = subscriptionEntry.watchers.indexOf(watcher);
            if (entryIndex >= 0) {
                subscriptionEntry.watchers.splice(entryIndex, 1);
            }
            if (subscriptionEntry.watchers.length === 0) {
                clearTimeout(subscriptionEntry.resourceTimer);
                if (subscriptionEntry.deletionIgnored) {
                    grpc_js_1.experimental.log(grpc_js_1.logVerbosity.INFO, 'Unsubscribing from resource with previously ignored deletion: ' + resourceName);
                }
                this.subscriptions.delete(resourceName);
                this.updateResourceNames();
            }
        }
    }
    getResourceNames() {
        return Array.from(this.subscriptions.keys());
    }
    handleResponses(responses) {
        let result = {
            accepted: [],
            rejected: [],
            missing: []
        };
        const allResourceNames = new Set();
        for (const { resource, raw } of responses) {
            const resourceName = this.getResourceName(resource);
            allResourceNames.add(resourceName);
            const subscriptionEntry = this.subscriptions.get(resourceName);
            if (this.validateResponse(resource)) {
                result.accepted.push({
                    name: resourceName,
                    raw: raw
                });
                if (subscriptionEntry) {
                    for (const watcher of subscriptionEntry.watchers) {
                        watcher.onValidUpdate(resource);
                    }
                    clearTimeout(subscriptionEntry.resourceTimer);
                    subscriptionEntry.cachedResponse = resource;
                    if (subscriptionEntry.deletionIgnored) {
                        grpc_js_1.experimental.log(grpc_js_1.logVerbosity.INFO, `Received resource with previously ignored deletion: ${resourceName}`);
                        subscriptionEntry.deletionIgnored = false;
                    }
                }
            }
            else {
                this.trace('Validation failed for message ' + JSON.stringify(resource));
                result.rejected.push({
                    name: resourceName,
                    raw: raw,
                    error: `Validation failed for resource ${resourceName}`
                });
                if (subscriptionEntry) {
                    for (const watcher of subscriptionEntry.watchers) {
                        watcher.onTransientError({
                            code: grpc_js_1.status.UNAVAILABLE,
                            details: `Validation failed for resource ${resourceName}`,
                            metadata: new grpc_js_1.Metadata()
                        });
                    }
                    clearTimeout(subscriptionEntry.resourceTimer);
                }
            }
        }
        result.missing = this.handleMissingNames(allResourceNames);
        this.trace('Received response with resource names [' + Array.from(allResourceNames) + ']');
        return result;
    }
    reportStreamError(status) {
        for (const subscriptionEntry of this.subscriptions.values()) {
            for (const watcher of subscriptionEntry.watchers) {
                watcher.onTransientError(status);
            }
            clearTimeout(subscriptionEntry.resourceTimer);
        }
        this.isAdsStreamRunning = false;
        this.nonce = '';
    }
    reportAdsStreamStart() {
        if (this.isAdsStreamRunning) {
            return;
        }
        this.isAdsStreamRunning = true;
        for (const subscriptionEntry of this.subscriptions.values()) {
            if (subscriptionEntry.cachedResponse === null) {
                this.startResourceTimer(subscriptionEntry);
            }
        }
    }
    handleMissingNames(allResponseNames) {
        if (this.isStateOfTheWorld()) {
            const missingNames = [];
            for (const [resourceName, subscriptionEntry] of this.subscriptions.entries()) {
                if (!allResponseNames.has(resourceName) && subscriptionEntry.cachedResponse !== null) {
                    if (this.ignoreResourceDeletion) {
                        if (!subscriptionEntry.deletionIgnored) {
                            grpc_js_1.experimental.log(grpc_js_1.logVerbosity.ERROR, 'Ignoring nonexistent resource ' + resourceName);
                            subscriptionEntry.deletionIgnored = true;
                        }
                    }
                    else {
                        this.trace('Reporting resource does not exist named ' + resourceName);
                        missingNames.push(resourceName);
                        for (const watcher of subscriptionEntry.watchers) {
                            watcher.onResourceDoesNotExist();
                        }
                        subscriptionEntry.cachedResponse = null;
                    }
                }
            }
            return missingNames;
        }
        else {
            return [];
        }
    }
    enableIgnoreResourceDeletion() {
        this.ignoreResourceDeletion = true;
    }
}
exports.BaseXdsStreamState = BaseXdsStreamState;
//# sourceMappingURL=xds-stream-state.js.map